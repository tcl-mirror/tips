diff -c -r orig_2/tk8.4a2/doc/text.n try/tk8.4a2/doc/text.n
*** orig_2/tk8.4a2/doc/text.n	Fri Aug 25 08:58:33 2000
--- try/tk8.4a2/doc/text.n	Sat Jul  7 20:04:52 2001
***************
*** 26,31 ****
--- 26,34 ----
  \-highlightcolor	\-pady	\-yscrollcommand
  .SE
  .SH "WIDGET-SPECIFIC OPTIONS"
+ .OP \-autoseparators autoSseparators AutoSeparators
+ Specifies whether separators are automatically inserted in the undo
+ stack. Is only active when the \fB\-undo\fR option is true.
  .OP \-height height Height
  Specifies the desired height for the window, in units of characters
  in the font given by the \fB\-font\fR option.
***************
*** 83,88 ****
--- 86,94 ----
  If no \fB\-tabs\fR option is specified, or if it is specified as
  an empty list, then Tk uses default tabs spaced every eight
  (average size) characters.
+ .OP \-undo undo Undo
+ Specifies whether the undo mechanism is active (value \fB0\fR) or
+ not (value \fB1\fR).
  .OP \-width width Width
  Specifies the desired width for the window in units of characters
  in the font given by the \fB\-font\fR option.
***************
*** 141,146 ****
--- 147,155 ----
  widget.
  See EMBEDDED IMAGES below for more details.
  .VE
+ .PP
+ The text widget also has a built-in undo/redo mechanism. See 
+ UNDO MECHANISM below for more details.
  
  .SH INDICES
  .PP
***************
*** 682,687 ****
--- 691,699 ----
  If the selection is claimed away by another application or by another
  window within this application, then the \fBsel\fR tag will be removed
  from all characters in the text.
+ .IP [4]
+ Whenever the \fBsel\fR tag range changes a virtual event 
+ \fB<<Selection>>\fR is generated.
  .PP
  The \fBsel\fR tag is automatically defined when a text widget is
  created, and it may not be deleted with the ``\fIpathName \fBtag delete\fR''
***************
*** 702,707 ****
--- 714,760 ----
  cursor, and the insertion cursor will automatically be drawn at
  this point whenever the text widget has the input focus.
  
+ .SH "THE MODIFIED FLAG"
+ The text widget can keep track of changes to the content of the widget
+ by means of the modified flag. Inserting or deleting text will set
+ this flag. The flag can be queried, set and cleared programatically
+ as well. Whenever the flag changes state a \fB<<Modified>>\fR virtual 
+ event is generated. See the \fBedit modified\fR widget command for 
+ more details.
+ 
+ .SH "THE UNDO MECHANISM"
+ .PP
+ The text widget has an unlimited undo and redo mechanism. This undo 
+ mechanism is only active when the \fB-undo\fR widget option is true.
+ Every insert and delete action is recorded on this stack.
+ .PP
+ Boundaries are inserted between edit actions: the so-called 
+ separators. The purpose of these separators is to group inserts and
+ deletes into one compound edit action. When undoing a change everything
+ between two separators will be undone. The undone changes are then
+ moved to the redo stack, so that an undone edit can be redone again.
+ The redo stack is cleared whenever new edit actions are recorded
+ on the undo stack. The undo and redo stacks can be cleared to keep 
+ their depth under control.
+ .PP
+ Separators are inserted automatically when the 
+ \fB-autoseparators\fR widget option is true. You can insert separators
+ programatically as well. If a separator is already present at the top
+ of the undo stack no other will inserted. That means that two 
+ separators on the undo stack are always separated by at least one 
+ insert or delete action.
+ .PP
+ The undo mechanism is also linked to the modified flag. This means
+ that undoing or redoing changes can take a modified text widget back 
+ to the unmodified state or vice versa. The modified flag
+ will be set to automatically to the appropriate state. This 
+ automatic coupling does not work when the modified flag has been 
+ set by the user, until the flag has been reset again. 
+ 
+ .PP
+ See below for the \fBedit\fR widget command that controls the 
+ undo mechanism.
+ 
  .SH "WIDGET COMMAND"
  .PP
  The \fBtext\fR command creates a new Tcl command whose
***************
*** 863,868 ****
--- 916,956 ----
  window by its index position to get more information.
  .RE
  .TP
+ \fIpathName \fBedit \fIoption \fR?\fIarg arg ...\fR?
+ This command controls the undo mechanism and the modified flag.  
+ The exact behavior of the command depends on the \fIoption\fR 
+ argument that follows the \fBedit\fR argument.  The following 
+ forms of the command are currently supported:
+ .RS
+ .TP
+ \fIpathName \fBedit modified ?\fIboolean\fR?
+ If \fIboolean\fR is not specified, returns the modified flag of
+ the widget. The insert, delete, edit undo and edit redo commands
+ or the user can set or clear the modified flag.
+ If \fIboolean\fR is specified, sets the modified flag of the widget
+ to \fIboolean\fR.
+ .TP
+ \fIpathName \fBedit redo\fR
+ When the \fB-undo\fR option is true, reapplies the last undone 
+ edits provided no other edits were done since then. Generates an
+ error when the redo stack is empty.
+ Does nothing when the \fB-undo\fR option is false.
+ .TP
+ \fIpathName \fBedit reset\fR
+ Clears the undo and redo stacks.
+ .TP
+ \fIpathName \fBedit separator\fR
+ Inserts a separator (boundary) on the undo stack. Does nothing
+ when the \fB-undo\fR option is false.
+ .TP
+ \fIpathName \fBedit undo\fR
+ Undoes the last edit action when the \fB-undo\fR option is true. 
+ An edit action is defined as all the insert and delete commands that are 
+ recorded on the undo stack in between two separators. Generates an error
+ when the undo stack is empty.
+ Does nothing when the \fB-undo\fR option is false.
+ .RE
+ .TP
  \fIpathName \fBget \fIindex1 \fR?\fIindex2\fR?
  Return a range of characters from the text.
  The return value will be all the characters in the text starting
***************
*** 1591,1596 ****
--- 1679,1690 ----
  .IP [31]
  Control-t reverses the order of the two characters to the right of
  the insertion cursor. 
+ .IP [32]
+ Control-z undoes the last edit action if the \fB-undo\fR option is
+ true. Does nothing otherwise.
+ .IP [33]
+ Control-Z reapplies the last undone edit action if the \fB-undo\fR 
+ option is true. Does nothing otherwise.
  .PP
  If the widget is disabled using the \fB\-state\fR option, then its
  view can still be adjusted and text can still be selected,
diff -c -r orig_2/tk8.4a2/generic/tkText.c try/tk8.4a2/generic/tkText.c
*** orig_2/tk8.4a2/generic/tkText.c	Tue Jul 25 02:05:40 2000
--- try/tk8.4a2/generic/tkText.c	Sun Jul  8 07:48:11 2001
***************
*** 42,47 ****
--- 42,50 ----
   */
  
  static Tk_ConfigSpec configSpecs[] = {
+     {TK_CONFIG_BOOLEAN, "-autoseparators", "autoSeparators",
+         "AutoSeparators", DEF_TEXT_AUTO_SEPARATORS,
+         Tk_Offset(TkText, autoSeparators), 0},
      {TK_CONFIG_BORDER, "-background", "background", "Background",
  	DEF_TEXT_BG_COLOR, Tk_Offset(TkText, border), TK_CONFIG_COLOR_ONLY},
      {TK_CONFIG_BORDER, "-background", "background", "Background",
***************
*** 129,134 ****
--- 132,139 ----
      {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
  	DEF_TEXT_TAKE_FOCUS, Tk_Offset(TkText, takeFocus),
  	TK_CONFIG_NULL_OK},
+     {TK_CONFIG_BOOLEAN, "-undo", "undo", "Undo",
+         DEF_TEXT_UNDO, Tk_Offset(TkText, undo), 0},
      {TK_CONFIG_INT, "-width", "width", "Width",
  	DEF_TEXT_WIDTH, Tk_Offset(TkText, width), 0},
      {TK_CONFIG_CUSTOM, "-wrap", "wrap", "Wrap",
***************
*** 292,297 ****
--- 297,304 ----
  			    int offset, char *buffer, int maxBytes));
  static int		TextSearchCmd _ANSI_ARGS_((TkText *textPtr,
  			    Tcl_Interp *interp, int argc, char **argv));
+ static int              TextEditCmd _ANSI_ARGS_((TkText *textPtr,
+                             Tcl_Interp *interp, int argc, char **argv));
  static int		TextWidgetCmd _ANSI_ARGS_((ClientData clientData,
  			    Tcl_Interp *interp, int argc, char **argv));
  static void		TextWorldChanged _ANSI_ARGS_((
***************
*** 304,309 ****
--- 311,336 ----
  static int		DumpSegment _ANSI_ARGS_((Tcl_Interp *interp, char *key,
  			    char *value, char * command, TkTextIndex *index,
  			    int what));
+ static int              TextEditUndo _ANSI_ARGS_((Tcl_Interp * interp,
+                             TkText *textPtr));
+ static int              TextEditRedo _ANSI_ARGS_((Tcl_Interp * interp,
+                             TkText *textPtr));
+ static char *           TextGetText _ANSI_ARGS_((TkTextIndex * index1,
+                             TkTextIndex * index2));
+ static void             pushStack _ANSI_ARGS_(( TkTextEditAtom ** stack, 
+                             TkTextEditAtom * elem ));
+ 
+ static TkTextEditAtom * popStack   _ANSI_ARGS_(( TkTextEditAtom ** stack ));
+ 
+ static void             clearStack _ANSI_ARGS_(( TkTextEditAtom ** stack ));
+ 
+ static void             insertSeparator _ANSI_ARGS_(( TkTextEditAtom ** stack ));
+ 
+ static void             updateDirtyFlag _ANSI_ARGS_((TkText *textPtr));
+ 
+ static void             setDirtyFlag  _ANSI_ARGS_((TkText *textPtr));
+ 
+ static void             resetDirtyFlag  _ANSI_ARGS_((TkText *textPtr));
  
  /*
   * The structure below defines text class behavior by means of procedures
***************
*** 426,431 ****
--- 453,465 ----
      textPtr->xScrollCmd = NULL;
      textPtr->yScrollCmd = NULL;
      textPtr->flags = 0;
+     textPtr->undo = 1;
+     textPtr->modifiedSet = 0;
+     textPtr->isDirty = 0;
+     textPtr->isDirtyIncrement = 1;
+     textPtr->undoStack = NULL;
+     textPtr->redoStack = NULL;
+     textPtr->autoSeparators = 1;
  
      /*
       * Create the "sel" tag and the "current" and "insert" marks.
***************
*** 489,494 ****
--- 523,529 ----
      size_t length;
      int c;
      TkTextIndex index1, index2;
+     char * string;
  
      if (argc < 2) {
  	Tcl_AppendResult(interp, "wrong # args: should be \"",
***************
*** 636,641 ****
--- 671,678 ----
  	    sprintf(buf, "%d %d %d %d %d", x, y, width, height, base);
  	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
  	}
+     } else if ((c == 'e') && (strncmp(argv[1], "edit", length) == 0)) {
+         result = TextEditCmd(textPtr, interp, argc, argv);
      } else if ((c == 'g') && (strncmp(argv[1], "get", length) == 0)) {
  	if ((argc != 3) && (argc != 4)) {
  	    Tcl_AppendResult(interp, "wrong # args: should be \"",
***************
*** 658,689 ****
  	if (TkTextIndexCmp(&index1, &index2) >= 0) {
  	    goto done;
  	}
! 	while (1) {
! 	    int offset, last, savedChar;
! 	    TkTextSegment *segPtr;
! 
! 	    segPtr = TkTextIndexToSeg(&index1, &offset);
! 	    last = segPtr->size;
! 	    if (index1.linePtr == index2.linePtr) {
! 		int last2;
! 
! 		if (index2.byteIndex == index1.byteIndex) {
! 		    break;
! 		}
! 		last2 = index2.byteIndex - index1.byteIndex + offset;
! 		if (last2 < last) {
! 		    last = last2;
! 		}
! 	    }
! 	    if (segPtr->typePtr == &tkTextCharType) {
! 		savedChar = segPtr->body.chars[last];
! 		segPtr->body.chars[last] = 0;
! 		Tcl_AppendResult(interp, segPtr->body.chars + offset,
! 			(char *) NULL);
! 		segPtr->body.chars[last] = savedChar;
! 	    }
! 	    TkTextIndexForwBytes(&index1, last-offset, &index1);
! 	}
      } else if ((c == 'i') && (strncmp(argv[1], "index", length) == 0)
  	    && (length >= 3)) {
  	char buf[200];
--- 695,704 ----
  	if (TkTextIndexCmp(&index1, &index2) >= 0) {
  	    goto done;
  	}
!         string = TextGetText(&index1,&index2);
!         Tcl_AppendResult(interp, string, (char *) NULL);
!         ckfree(string);
!         
      } else if ((c == 'i') && (strncmp(argv[1], "index", length) == 0)
  	    && (length >= 3)) {
  	char buf[200];
***************
*** 771,778 ****
      } else {
  	Tcl_AppendResult(interp, "bad option \"", argv[1],
  		"\": must be bbox, cget, compare, configure, debug, delete, ",
! 		"dlineinfo, dump, get, image, index, insert, mark, scan, ",
! 		"search, see, tag, window, xview, or yview",
  		(char *) NULL);
  	result = TCL_ERROR;
      }
--- 786,793 ----
      } else {
  	Tcl_AppendResult(interp, "bad option \"", argv[1],
  		"\": must be bbox, cget, compare, configure, debug, delete, ",
!                 "dlineinfo, dump, edit, get, image, index, insert, mark, ",
!                 "scan, search, see, tag, window, xview, or yview",
  		(char *) NULL);
  	result = TCL_ERROR;
      }
***************
*** 1209,1214 ****
--- 1224,1232 ----
  {
      int lineIndex, resetView, offset;
      TkTextIndex newTop;
+     TkTextEditAtom * insertion;
+     char indexBuffer[TK_POS_CHARS];
+     
  
      /*
       * Don't allow insertions on the last (dummy) line of the text.
***************
*** 1237,1242 ****
--- 1255,1286 ----
      }
      TkTextChanged(textPtr, indexPtr, indexPtr);
      TkBTreeInsertChars(indexPtr, string);
+ 
+     /*
+      * Push the insertion on the undo stack
+      */
+ 
+     if ( textPtr->undo ) {
+         if (textPtr->autoSeparators && textPtr->undoStack &&
+             textPtr->undoStack->type != INSERT) {
+             insertSeparator(&(textPtr->undoStack));
+         }
+         
+         insertion = (TkTextEditAtom *) ckalloc(sizeof(TkTextEditAtom));
+         insertion->type = INSERT;
+         
+         TkTextPrintIndex(indexPtr,indexBuffer);
+         insertion->index = (char *) ckalloc(strlen(indexBuffer) + 1);
+         strcpy(insertion->index,indexBuffer);
+         
+         insertion->string = (char *) ckalloc(strlen(string) + 1);
+         strcpy(insertion->string,string);
+ 
+         pushStack(&(textPtr->undoStack),insertion);
+         clearStack(&(textPtr->redoStack));
+     }
+     updateDirtyFlag(textPtr);
+ 
      if (resetView) {
  	TkTextMakeByteIndex(textPtr->tree, lineIndex, 0, &newTop);
  	TkTextIndexForwBytes(&newTop, offset, &newTop);
***************
*** 1280,1285 ****
--- 1324,1331 ----
  {
      int line1, line2, line, byteIndex, resetView;
      TkTextIndex index1, index2;
+     TkTextEditAtom * deletion;
+     char indexBuffer[TK_POS_CHARS];
  
      /*
       * Parse the starting and stopping indices.
***************
*** 1391,1396 ****
--- 1437,1467 ----
  	    byteIndex -= (index2.byteIndex - index1.byteIndex);
  	}
      }
+     
+     
+     /*
+      * Push the deletion on the undo stack
+      */
+ 
+     if ( textPtr->undo ) {
+         if (textPtr->autoSeparators && textPtr->undoStack && textPtr->undoStack->type != DELETE) {
+            insertSeparator(&(textPtr->undoStack));
+         }
+         
+         deletion = (TkTextEditAtom *) ckalloc(sizeof(TkTextEditAtom));
+         deletion->type = DELETE;
+         
+         TkTextPrintIndex(&index1,indexBuffer);
+         deletion->index = (char *) ckalloc(strlen(indexBuffer) + 1);
+         strcpy(deletion->index,indexBuffer);
+         
+         deletion->string = TextGetText(&index1, &index2);
+ 
+         pushStack(&(textPtr->undoStack),deletion);
+         clearStack(&(textPtr->redoStack));
+     }
+     updateDirtyFlag(textPtr);
+ 
      TkBTreeDeleteChars(&index1, &index2);
      if (resetView) {
  	TkTextMakeByteIndex(textPtr->tree, line, byteIndex, &index1);
***************
*** 1572,1577 ****
--- 1643,1649 ----
      register TkText *textPtr = (TkText *) clientData;
  #ifdef ALWAYS_SHOW_SELECTION
      TkTextIndex start, end;
+     char selMessage[1000];
  
      if (!textPtr->exportSelection) {
  	return;
***************
*** 1588,1593 ****
--- 1660,1668 ----
      TkTextRedrawTag(textPtr, &start, &end, textPtr->selTagPtr, 1);
      TkBTreeTag(&start, &end, textPtr->selTagPtr, 0);
  #endif
+     /* Send an event that the selection changed */
+     sprintf(selMessage,"event generate %s <<Selection>>",Tk_PathName(textPtr->tkwin));
+     Tcl_Eval(textPtr->interp,selMessage);
      textPtr->flags &= ~GOT_SELECTION;
  }
  
***************
*** 2421,2423 ****
--- 2496,2990 ----
      }
  }
  
+ 
+ /*
+  * pushStack
+  *    Push elem on the stack identified by stack.
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static void pushStack ( stack, elem )
+     TkTextEditAtom ** stack;
+     TkTextEditAtom *  elem;
+ { 
+     elem->next = *stack;
+     *stack = elem;
+ }
+ 
+ 
+ /*
+  * popStack --
+  *    Remove and return the top element from the stack identified by 
+  *      stack.
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ TkTextEditAtom * popStack ( stack )
+     TkTextEditAtom ** stack ;
+ { 
+     TkTextEditAtom * elem = NULL;
+     if (*stack != NULL ) {
+         elem   = *stack;
+         *stack = elem->next;
+     }
+     return elem;
+ }
+ 
+ 
+ /*
+  * insertSeparator --
+  *    insert a separator on the stack, indicating a border for
+  *      an undo/redo chunk.
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static void insertSeparator ( stack )
+     TkTextEditAtom ** stack;
+ {
+     TkTextEditAtom * separator;
+ 
+     if ( *stack != NULL && (*stack)->type != SEPARATOR ) {
+         separator = (TkTextEditAtom *) ckalloc(sizeof(TkTextEditAtom));
+         separator->type = SEPARATOR;
+         pushStack(stack,separator);
+     }
+ }
+ 
+ 
+ /*
+  * clearStack --
+  *    Clear an entire undo or redo stack and destroy all elements in it.
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static void clearStack ( stack )
+     TkTextEditAtom ** stack;      /* An Undo or Redo stack */
+ {
+     TkTextEditAtom * elem;
+ 
+     while ( (elem = popStack(stack)) ) {
+         if ( elem->type != SEPARATOR ) {
+             ckfree(elem->index);
+             ckfree(elem->string);
+         }
+         ckfree((char *)elem);
+     }
+     *stack = NULL;
+ }
+ 
+ 
+ /*
+  * TextEditUndo --
+  *    undo the last change.
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static int TextEditUndo (interp,textPtr)
+     Tcl_Interp * interp;
+     TkText     * textPtr;             /* Overall information about text widget. */
+ {
+     TkTextEditAtom * elem      ;
+     TkTextIndex      fromIndex ;
+     TkTextIndex      toIndex   ;
+     char             buffer[TK_POS_CHARS];
+     char             viewIndex[TK_POS_CHARS];
+     
+     if ( ! textPtr->undo ) {
+        return TCL_OK;
+     }
+     
+ 
+     /* Turn off the undo feature */
+     
+     textPtr->undo = 0;
+     
+     /* insert a separator on the redo stack */
+     
+     insertSeparator(&(textPtr->redoStack));
+     
+     /* Pop and skip the first separator if there is one*/
+     
+     elem = popStack(&(textPtr->undoStack));
+ 
+     if ( elem == NULL ) {
+         textPtr->undo = 1;
+         return TCL_ERROR;
+     }
+     
+     if ( ( elem != NULL ) && ( elem->type == SEPARATOR ) ) {
+         ckfree((char *) elem);
+         elem = popStack(&(textPtr->undoStack));
+     }
+     
+     while ( elem && (elem->type != SEPARATOR) ) {
+         switch ( elem->type ) {
+             case INSERT:
+                 TkTextGetIndex(interp,textPtr,elem->index,&toIndex);
+                 strcpy(viewIndex,elem->index);
+                 TkTextIndexForwBytes(&toIndex,(int)strlen(elem->string),&toIndex);
+                 TkTextPrintIndex(&toIndex,buffer);
+                 textPtr->isDirtyIncrement = -1;
+                 DeleteChars(textPtr,elem->index,buffer);
+                 textPtr->isDirtyIncrement = 1;
+                 break;
+             case DELETE: 
+                 TkTextGetIndex(interp,textPtr,elem->index,&fromIndex);
+                 textPtr->isDirtyIncrement = -1;
+                 InsertChars(textPtr,&fromIndex,elem->string);
+                 TkTextIndexForwBytes(&fromIndex,(int)strlen(elem->string),&toIndex);
+                 TkTextPrintIndex(&toIndex,viewIndex);
+                 textPtr->isDirtyIncrement = 1;
+                 break;
+             default:
+                 return TCL_ERROR;
+         }
+         pushStack(&(textPtr->redoStack),elem);
+         elem = popStack(&(textPtr->undoStack));
+     }
+     
+     /* view the last changed position */
+     
+     TkTextGetIndex(interp,textPtr,viewIndex,&toIndex);
+     TkTextSetMark(textPtr, "insert", &toIndex);
+ 
+     /* insert a separator on the undo stack */
+     
+     insertSeparator(&(textPtr->undoStack));
+     
+     /* Turn back on the undo feature */
+     
+     textPtr->undo = 1;
+     
+     return TCL_OK;
+ }
+ 
+ 
+ /*
+  * TextEditRedo --
+  *    redo the last undone change.
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static int TextEditRedo (interp,textPtr)
+     Tcl_Interp * interp;
+     TkText     * textPtr;             /* Overall information about text widget. */
+ {
+     TkTextEditAtom * elem      ;
+     TkTextIndex      fromIndex ;
+     TkTextIndex      toIndex   ;
+     char             buffer[TK_POS_CHARS];
+     char             viewIndex[TK_POS_CHARS];
+     
+     if ( ! textPtr->undo ) {
+        return TCL_OK;
+     }
+     
+     /* Turn off the undo feature temporarily */
+     
+     textPtr->undo = 0;
+     
+     /* insert a separator on the undo stack */
+     
+     insertSeparator(&(textPtr->undoStack));
+     
+     /* Pop and skip the first separator if there is one*/
+     
+     elem = popStack(&(textPtr->redoStack));
+ 
+     if ( elem == NULL ) {
+        textPtr->undo = 1;
+        return TCL_ERROR;
+     }
+     
+     if ( ( elem != NULL ) && ( elem->type == SEPARATOR ) ) {
+         ckfree((char *) elem);
+         elem = popStack(&(textPtr->redoStack));
+     }
+     
+     while ( elem && (elem->type != SEPARATOR) ) {
+         switch ( elem->type ) {
+             case INSERT:
+                 TkTextGetIndex(interp,textPtr,elem->index,&fromIndex);
+                 InsertChars(textPtr,&fromIndex,elem->string);
+                 TkTextIndexForwBytes(&fromIndex,(int)strlen(elem->string),&toIndex);
+                 TkTextPrintIndex(&toIndex,viewIndex);
+                 break;
+             case DELETE: 
+                 TkTextGetIndex(interp,textPtr,elem->index,&toIndex);
+                 strcpy(viewIndex,elem->index);
+                 TkTextIndexForwBytes(&toIndex,(int)strlen(elem->string),&toIndex);
+                 TkTextPrintIndex(&toIndex,buffer);
+                 DeleteChars(textPtr,elem->index,buffer);
+                 break;
+             default:
+                 return TCL_ERROR;
+         }
+         pushStack(&(textPtr->undoStack),elem);
+         elem = popStack(&(textPtr->redoStack));
+     }
+     
+     /* view the last changed position */
+     
+     TkTextGetIndex(interp,textPtr,viewIndex,&toIndex);
+     TkTextSetMark(textPtr, "insert", &toIndex);
+ 
+     /* insert a separator on the undo stack */
+     
+     insertSeparator(&(textPtr->undoStack));
+ 
+     /* Turn back on the undo feature */
+     
+     textPtr->undo = 1;
+     
+     return TCL_OK;
+ }
+ 
+ static int
+ TextEditCmd(textPtr, interp, argc, argv)
+     TkText *textPtr;          /* Information about text widget. */
+     Tcl_Interp *interp;               /* Current interpreter. */
+     int argc;                 /* Number of arguments. */
+     char **argv;              /* Argument strings. */
+ {
+     int      c            ;
+     size_t   length       ;
+     int      setModified  ;
+     
+     if (argc < 3) {
+       Tcl_AppendResult(interp, "wrong # args: should be \"",
+               argv[0], " edit option ?arg arg ...?\"", (char *) NULL);
+       return TCL_ERROR;
+     }
+     c = argv[2][0];
+     length = strlen(argv[2]);
+     if ((c == 'm') && (strncmp(argv[2], "modified", length) == 0)) {
+       if (argc != 3) {
+ 	    if (Tcl_GetBoolean(interp, argv[3], &setModified) == TCL_OK) {
+                 if ( argc != 4 ) {
+                   Tcl_AppendResult(interp, "wrong # args: should be \"",
+                           argv[0], " edit modified ?boolean? \"", (char *) NULL);
+                   return TCL_ERROR;
+                 }
+                 if ( setModified ) {
+                     setDirtyFlag(textPtr);
+                 } else {
+                     resetDirtyFlag(textPtr);
+                 }
+             } else {
+               Tcl_AppendResult(interp, "bad modified option \"", argv[3],
+                       "\": must be a boolean",
+                       (char *) NULL);
+               return TCL_ERROR;
+             }
+       } else {
+             if (textPtr->isDirty) {
+                 Tcl_AppendResult(interp, "1",(char *) NULL);
+             } else {
+                 Tcl_AppendResult(interp, "0",(char *) NULL);
+             }
+         }
+     } else if ((c == 'r') && (strncmp(argv[2], "redo", length) == 0)  && (length >= 3)) {
+       if (argc != 3) {
+           Tcl_AppendResult(interp, "wrong # args: should be \"",
+                   argv[0], " edit redo \"", (char *) NULL);
+           return TCL_ERROR;
+       }
+         if ( TextEditRedo(interp,textPtr) ) {
+             Tcl_AppendResult(interp, "nothing to redo",
+                   (char *) NULL);
+           return TCL_ERROR;
+         }
+     } else if ((c == 'r') && (strncmp(argv[2], "reset", length) == 0) && (length >= 3)) {
+       if (argc != 3) {
+           Tcl_AppendResult(interp, "wrong # args: should be \"",
+                   argv[0], " edit reset \"", (char *) NULL);
+           return TCL_ERROR;
+       }
+         clearStack(&(textPtr->undoStack));
+         clearStack(&(textPtr->redoStack));
+     } else if ((c == 's') && (strncmp(argv[2], "separator", length) == 0)) {
+       if (argc != 3) {
+           Tcl_AppendResult(interp, "wrong # args: should be \"",
+                   argv[0], " edit separator \"", (char *) NULL);
+           return TCL_ERROR;
+       }
+         insertSeparator(&(textPtr->undoStack));
+     } else if ((c == 'u') && (strncmp(argv[2], "undo", length) == 0)) {
+       if (argc != 3) {
+           Tcl_AppendResult(interp, "wrong # args: should be \"",
+                   argv[0], " edit undo \"", (char *) NULL);
+           return TCL_ERROR;
+       }
+         if ( TextEditUndo(interp,textPtr) ) {
+             Tcl_AppendResult(interp, "nothing to undo",
+                   (char *) NULL);
+           return TCL_ERROR;
+         }
+     } else {
+       Tcl_AppendResult(interp, "bad edit option \"", argv[2],
+               "\": must be modified, redo, reset, separator or undo",
+               (char *) NULL);
+       return TCL_ERROR;
+     }
+     
+     return TCL_OK;
+ }
+ 
+ 
+ 
+ /*
+  * TextGetText --
+  *    returns the text from indexPtr1 to indexPtr2.
+  *
+  * Results:
+  *    the string between indices indexPtr1 and indexPtr2
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ char * TextGetText(indexPtr1,indexPtr2)
+     TkTextIndex * indexPtr1;
+     TkTextIndex * indexPtr2;
+ {
+     TkTextIndex tmpIndex;
+     char * string;
+     string = (char *) ckalloc(1);
+     *string = '\0';
+     
+     TkTextMakeByteIndex(indexPtr1->tree,TkBTreeLineIndex(indexPtr1->linePtr),indexPtr1->byteIndex,&tmpIndex);
+ 
+     if (TkTextIndexCmp(indexPtr1, indexPtr2) >= 0) {
+       return string;
+     }
+     while (1) {
+       int offset, last, savedChar;
+       TkTextSegment *segPtr;
+ 
+       segPtr = TkTextIndexToSeg(&tmpIndex, &offset);
+       last = segPtr->size;
+       if (tmpIndex.linePtr == indexPtr2->linePtr) {
+           int last2;
+ 
+           if (indexPtr2->byteIndex == tmpIndex.byteIndex) {
+               break;
+           }
+           last2 = indexPtr2->byteIndex - tmpIndex.byteIndex + offset;
+           if (last2 < last) {
+               last = last2;
+           }
+       }
+       if (segPtr->typePtr == &tkTextCharType) {
+           savedChar = segPtr->body.chars[last];
+           segPtr->body.chars[last] = 0;
+             string = (char *) ckrealloc(string,strlen(string) + strlen(segPtr->body.chars + offset) + 1);
+             strcat(string,segPtr->body.chars + offset);
+           segPtr->body.chars[last] = savedChar;
+       }
+       TkTextIndexForwBytes(&tmpIndex, last-offset, &tmpIndex);
+     }
+ 
+     return string;
+ }
+ 
+ 
+ /*
+  * updateDirtyFlag --
+  *    increases the dirtyness of the text widget
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static void updateDirtyFlag (textPtr)
+     TkText *textPtr;          /* Information about text widget. */
+ {
+     char eventMessage[1000];
+     int oldDirtyFlag;
+ 
+     if ( textPtr->modifiedSet ) {
+         return;
+     }
+     oldDirtyFlag = textPtr->isDirty;
+     textPtr->isDirty += textPtr->isDirtyIncrement;
+     if (textPtr->isDirty == 0 || oldDirtyFlag == 0) {
+         sprintf(eventMessage,"event generate %s <<Modified>>",Tk_PathName(textPtr->tkwin));
+         Tcl_Eval(textPtr->interp,eventMessage);
+     }
+ }
+ 
+ /*
+  * setDirtyFlag --
+  *    sets the dirtyness of the text widget
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static void setDirtyFlag (textPtr)
+     TkText *textPtr;          /* Information about text widget. */
+ {
+     char eventMessage[1000];
+     textPtr->isDirty = 1;
+     textPtr->modifiedSet = 1;
+     sprintf(eventMessage,"event generate %s <<Modified>>",Tk_PathName(textPtr->tkwin));
+     Tcl_Eval(textPtr->interp,eventMessage);
+ }
+   
+ /*
+  * resetDirtyFlag --
+  *    resets the dirtyness of the text widget
+  *
+  * Results:
+  *    None
+  *
+  * Side effects:
+  *    None.
+  */
+  
+ static void resetDirtyFlag (textPtr)
+     TkText *textPtr;          /* Information about text widget. */
+ {
+     char eventMessage[1000];
+     textPtr->isDirty = 0;
+     textPtr->modifiedSet = 0;
+     sprintf(eventMessage,"event generate %s <<Modified>>",Tk_PathName(textPtr->tkwin));
+     Tcl_Eval(textPtr->interp,eventMessage);
+ }
+   
diff -c -r orig_2/tk8.4a2/generic/tkText.h try/tk8.4a2/generic/tkText.h
*** orig_2/tk8.4a2/generic/tkText.h	Thu Jan  6 03:18:58 2000
--- try/tk8.4a2/generic/tkText.h	Sat Jul  7 19:35:34 2001
***************
*** 451,456 ****
--- 451,473 ----
  					 * BE THE LAST IN THE STRUCTURE. */
  } TkTextTabArray;
  
+ /* enum definining the types used in an edit stack */
+ 
+ typedef enum {
+     SEPARATOR,                          /* Marker */
+     INSERT,                             /* The undo is an insert */
+     DELETE                              /* The undo is a delete */
+ } TkTextEditType;
+ 
+ /* strcut defining the basic undo/redo stack element */
+ 
+ typedef struct TkTextEditAtom {
+     TkTextEditType type;                /* The type that will trigger the required action*/
+     char * index;                       /* The starting index of the range */
+     char * string;                      /* The text to be inserted or deleted */
+     struct TkTextEditAtom * next;       /* Pointer to the next element in the stack */
+ } TkTextEditAtom;
+ 
  /*
   * A data structure of the following type is kept for each text widget that
   * currently exists for this process:
***************
*** 625,630 ****
--- 642,675 ----
  				 * vertical scrollbar when view changes. */
      int flags;			/* Miscellaneous flags;  see below for
  				 * definitions. */
+ 
+     /*
+      * Information related to the undo/redo functonality
+      */
+      
+     TkTextEditAtom * undoStack; /* The undo stack */
+     
+     TkTextEditAtom * redoStack; /* The redo stack */
+     
+     int undo;                   /* non zero means the undo/redo behaviour is 
+                                  * enabled */
+     
+     int autoSeparators;         /* non zero means the separatorss will be 
+                                  * inserted automatically */
+     
+     int modifiedSet;            /* Flag indicating that the 'dirtynesss' of
+                                  * the text widget has been expplicitly set.
+                                  */
+ 
+     int isDirty;                /* Flag indicating the 'dirtynesss' of the text
+                                  * widget. If the flag is not zero, unsaved 
+                                  * modifications have been applied to the
+                                  * text widget */
+ 
+     int isDirtyIncrement;       /* Amount with which the isDirty flag is
+                                  * incremented every edit action
+                                  */
+ 
  } TkText;
  
  /*
diff -c -r orig_2/tk8.4a2/generic/tkTextTag.c try/tk8.4a2/generic/tkTextTag.c
*** orig_2/tk8.4a2/generic/tkTextTag.c	Thu Jan  6 03:18:59 2000
--- try/tk8.4a2/generic/tkTextTag.c	Sat Feb 17 11:27:04 2001
***************
*** 114,119 ****
--- 114,120 ----
      char *fullOption;
      register TkTextTag *tagPtr;
      TkTextIndex first, last, index1, index2;
+     char selMessage[1000];
  
      if (argc < 3) {
  	Tcl_AppendResult(interp, "wrong # args: should be \"",
***************
*** 171,176 ****
--- 172,180 ----
  	     */
      
  	    if (tagPtr == textPtr->selTagPtr) {
+                 /* Send an event that the selection changed */
+                 sprintf(selMessage,"event generate %s <<Selection>>",Tk_PathName(textPtr->tkwin));
+                 Tcl_Eval(textPtr->interp,selMessage);
  		if (addTag && textPtr->exportSelection
  			&& !(textPtr->flags & GOT_SELECTION)) {
  		    Tk_OwnSelection(textPtr->tkwin, XA_PRIMARY,
***************
*** 462,467 ****
--- 466,478 ----
  	    TkTextMakeByteIndex(textPtr->tree, TkBTreeNumLines(textPtr->tree),
  		    0, &last),
  	    TkBTreeTag(&first, &last, tagPtr, 0);
+ 
+             if (tagPtr == textPtr->selTagPtr) {
+                 /* Send an event that the selection changed */
+                 sprintf(selMessage,"event generate %s <<Selection>>",Tk_PathName(textPtr->tkwin));
+                 Tcl_Eval(textPtr->interp,selMessage);
+             }
+ 
  	    Tcl_DeleteHashEntry(hPtr);
  	    if (textPtr->bindingTable != NULL) {
  		Tk_DeleteAllBindings(textPtr->bindingTable,
diff -c -r orig_2/tk8.4a2/library/text.tcl try/tk8.4a2/library/text.tcl
*** orig_2/tk8.4a2/library/text.tcl	Thu Jul 20 01:22:20 2000
--- try/tk8.4a2/library/text.tcl	Sun Jul  8 07:26:00 2001
***************
*** 204,209 ****
--- 204,210 ----
  }
  bind Text <Return> {
      tkTextInsert %W \n
+     if {[%W cget -autoseparators]} {%W edit separator}
  }
  bind Text <Delete> {
      if {[string compare [%W tag nextrange sel 1.0 end] ""]} {
***************
*** 338,343 ****
--- 339,356 ----
      }
  }
  
+ bind Text <<Undo>> {
+     if { ! [ catch { %W edit undo } ] } {
+        %W see insert
+     }
+ }
+ 
+ bind Text <<Redo>> {
+     if { ! [ catch { %W edit redo } ] } {
+        %W see insert
+     }
+ }
+ 
  if {[string compare $tcl_platform(platform) "windows"]} {
  bind Text <Control-v> {
      if {!$tk_strictMotif} {
***************
*** 518,523 ****
--- 531,537 ----
      $w mark set insert [tkTextClosestGap $w $x $y]
      $w mark set anchor insert
      if {[string equal [$w cget -state] "normal"]} {focus $w}
+     if {[$w cget -autoseparators]} {$w edit separator}
  }
  
  # tkTextSelectTo --
***************
*** 633,639 ****
  
  proc tkTextPaste {w x y} {
      $w mark set insert [tkTextClosestGap $w $x $y]
!     catch {$w insert insert [selection get -displayof $w]}
      if {[string equal [$w cget -state] "normal"]} {focus $w}
  }
  
--- 647,664 ----
  
  proc tkTextPaste {w x y} {
      $w mark set insert [tkTextClosestGap $w $x $y]
!     catch {
!         set oldSeparator [$w cget -autoseparators]
!         if {$oldSeparator} {
!             $w configure -autoseparators 0
!             $w edit separator
!         }
!         $w insert insert [selection get -displayof $w]
!         if {$oldSeparator} {
!            $w edit separator
!            $w configure -autoseparators 1
!         }
!     }
      if {[string equal [$w cget -state] "normal"]} {focus $w}
  }
  
***************
*** 685,690 ****
--- 710,716 ----
      $w mark set insert $pos
      $w tag remove sel 1.0 end
      $w see insert
+     if {[$w cget -autoseparators]} {$w edit separator}
  }
  
  # tkTextKeySelect
***************
*** 794,807 ****
--- 820,844 ----
      if {[string equal $s ""] || [string equal [$w cget -state] "disabled"]} {
  	return
      }
+     set compound 0
      catch {
  	if {[$w compare sel.first <= insert] \
  		&& [$w compare sel.last >= insert]} {
+             set oldSeparator [$w cget -autoseparators]
+             if { $oldSeparator } {
+                 $w configure -autoseparators 0
+                 $w edit separator
+                 set compound 1
+             }
  	    $w delete sel.first sel.last
  	}
      }
      $w insert insert $s
      $w see insert
+     if { $compound && $oldSeparator } {
+         $w edit separator
+         $w configure -autoseparators 1
+     }
  }
  
  # tkTextUpDownLine --
***************
*** 975,986 ****
--- 1012,1032 ----
  proc tk_textPaste w {
      global tcl_platform
      catch {
+         set oldSeparator [$w cget -autoseparators]
+         if { $oldSeparator } {
+             $w configure -autoseparators 0
+             $w edit separator
+         }
  	if {[string compare $tcl_platform(platform) "unix"]} {
  	    catch {
  		$w delete sel.first sel.last
  	    }
  	}
  	$w insert insert [selection get -displayof $w -selection CLIPBOARD]
+         if { $oldSeparator } {
+             $w edit separator
+             $w configure -autoseparators 1
+         }
      }
  }
  
diff -c -r orig_2/tk8.4a2/library/tk.tcl try/tk8.4a2/library/tk.tcl
*** orig_2/tk8.4a2/library/tk.tcl	Tue Oct 31 02:12:38 2000
--- try/tk8.4a2/library/tk.tcl	Sat Jul  7 19:50:09 2001
***************
*** 281,286 ****
--- 281,288 ----
  	event add <<Copy>> <Control-Key-c> <Key-F16>
  	event add <<Paste>> <Control-Key-v> <Key-F18>
  	event add <<PasteSelection>> <ButtonRelease-2>
+ 	event add <<Undo>> <Control-Key-z>
+ 	event add <<Redo>> <Control-Key-Z>
  	# Some OS's define a goofy (as in, not <Shift-Tab>) keysym
  	# that is returned when the user presses <Shift-Tab>.  In order for
  	# tab traversal to work, we have to add these keysyms to the 
***************
*** 302,307 ****
--- 304,311 ----
  	event add <<Copy>> <Control-Key-c> <Control-Key-Insert>
  	event add <<Paste>> <Control-Key-v> <Shift-Key-Insert>
  	event add <<PasteSelection>> <ButtonRelease-2>
+   	event add <<Undo>> <Control-Key-z>
+ 	event add <<Redo>> <Control-Key-y>
      }
      "macintosh" {
  	event add <<Cut>> <Control-Key-x> <Key-F2> 
***************
*** 309,314 ****
--- 313,320 ----
  	event add <<Paste>> <Control-Key-v> <Key-F4>
  	event add <<PasteSelection>> <ButtonRelease-2>
  	event add <<Clear>> <Clear>
+ 	event add <<Undo>> <Control-Key-z>
+ 	event add <<Redo>> <Control-Key-Z>
      }
  }
  
diff -c -r orig_2/tk8.4a2/mac/tkMacDefault.h try/tk8.4a2/mac/tkMacDefault.h
*** orig_2/tk8.4a2/mac/tkMacDefault.h	Fri Jul 28 18:34:55 2000
--- try/tk8.4a2/mac/tkMacDefault.h	Sat Jul  7 19:46:34 2001
***************
*** 419,424 ****
--- 419,425 ----
   * Defaults for texts:
   */
  
+ #define DEF_TEXT_AUTO_SEPARATORS	"1"
  #define DEF_TEXT_BG_COLOR		NORMAL_BG
  #define DEF_TEXT_BG_MONO		WHITE
  #define DEF_TEXT_BORDER_WIDTH		"0"
***************
*** 453,458 ****
--- 454,460 ----
  #define DEF_TEXT_STATE			"normal"
  #define DEF_TEXT_TABS			""
  #define DEF_TEXT_TAKE_FOCUS		(char *) NULL
+ #define DEF_TEXT_UNDO    		"0"
  #define DEF_TEXT_WIDTH			"80"
  #define DEF_TEXT_WRAP			"char"
  #define DEF_TEXT_XSCROLL_COMMAND	""
diff -c -r orig_2/tk8.4a2/tests/text.test try/tk8.4a2/tests/text.test
*** orig_2/tk8.4a2/tests/text.test	Tue Jul 25 02:05:40 2000
--- try/tk8.4a2/tests/text.test	Sat Jul  7 20:00:20 2001
***************
*** 51,56 ****
--- 51,57 ----
  text .t2
  set i 0
  foreach test {
+     {-autoseparators yes 1 nah}
      {-background #ff00ff #ff00ff <gorp>}
      {-bd 4 4 foo}
      {-bg blue blue #xx}
***************
*** 83,88 ****
--- 84,90 ----
      {-spacing3 -10 0 bogus}
      {-state d disabled foo}
      {-tabs {1i 2i 3i 4i} {1i 2i 3i 4i} bad_tabs}
+     {-undo 1 1 eh}
      {-width 73 73 2.4}
      {-wrap w word bad_wrap}
  } {
***************
*** 111,117 ****
  	lappend result [lindex $i 4]
      }
      set result
! } {blue {} {} 7 watch 0 {} fixed #012 5 #123 #234 0 green 45 100 47 2 3 82 raised #ffff01234567 21 yellow 0 0 0 0 disabled {1i 2i 3i 4i} {any old thing} 73 word {x scroll command} {test command}}
  
  test text-2.1 {Tk_TextCmd procedure} {
      list [catch {text} msg] $msg
--- 113,119 ----
  	lappend result [lindex $i 4]
      }
      set result
! } {1 blue {} {} 7 watch 0 {} fixed #012 5 #123 #234 0 green 45 100 47 2 3 82 raised #ffff01234567 21 yellow 0 0 0 0 disabled {1i 2i 3i 4i} {any old thing} 1 73 word {x scroll command} {test command}}
  
  test text-2.1 {Tk_TextCmd procedure} {
      list [catch {text} msg] $msg
***************
*** 150,156 ****
  } {1 {wrong # args: should be ".t option ?arg arg ...?"}}
  test text-3.2 {TextWidgetCmd procedure} {
      list [catch {.t gorp 1.0 z 1.2} msg] $msg
! } {1 {bad option "gorp": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  
  test text-4.1 {TextWidgetCmd procedure, "bbox" option} {
      list [catch {.t bbox} msg] $msg
--- 152,158 ----
  } {1 {wrong # args: should be ".t option ?arg arg ...?"}}
  test text-3.2 {TextWidgetCmd procedure} {
      list [catch {.t gorp 1.0 z 1.2} msg] $msg
! } {1 {bad option "gorp": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, edit, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  
  test text-4.1 {TextWidgetCmd procedure, "bbox" option} {
      list [catch {.t bbox} msg] $msg
***************
*** 218,224 ****
  } {1 {bad comparison operator "z": must be <, <=, ==, >=, >, or !=}}
  test text-6.14 {TextWidgetCmd procedure, "compare" option} {
      list [catch {.t co 1.0 z 1.2} msg] $msg
! } {1 {bad option "co": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  
  # "configure" option is already covered above
  
--- 220,226 ----
  } {1 {bad comparison operator "z": must be <, <=, ==, >=, >, or !=}}
  test text-6.14 {TextWidgetCmd procedure, "compare" option} {
      list [catch {.t co 1.0 z 1.2} msg] $msg
! } {1 {bad option "co": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, edit, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  
  # "configure" option is already covered above
  
***************
*** 227,233 ****
  } {1 {wrong # args: should be ".t debug boolean"}}
  test text-7.2 {TextWidgetCmd procedure, "debug" option} {
      list [catch {.t de 0 1} msg] $msg
! } {1 {bad option "de": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  test text-7.3 {TextWidgetCmd procedure, "debug" option} {
      .t debug true
      .t deb
--- 229,235 ----
  } {1 {wrong # args: should be ".t debug boolean"}}
  test text-7.2 {TextWidgetCmd procedure, "debug" option} {
      list [catch {.t de 0 1} msg] $msg
! } {1 {bad option "de": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, edit, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  test text-7.3 {TextWidgetCmd procedure, "debug" option} {
      .t debug true
      .t deb
***************
*** 310,316 ****
  } {1 {wrong # args: should be ".t index index"}}
  test text-10.3 {TextWidgetCmd procedure, "index" option} {
      list [catch {.t in a b} msg] $msg
! } {1 {bad option "in": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  test text-10.4 {TextWidgetCmd procedure, "index" option} {
      list [catch {.t index @xyz} msg] $msg
  } {1 {bad text index "@xyz"}}
--- 312,318 ----
  } {1 {wrong # args: should be ".t index index"}}
  test text-10.3 {TextWidgetCmd procedure, "index" option} {
      list [catch {.t in a b} msg] $msg
! } {1 {bad option "in": must be bbox, cget, compare, configure, debug, delete, dlineinfo, dump, edit, get, image, index, insert, mark, scan, search, see, tag, window, xview, or yview}}
  test text-10.4 {TextWidgetCmd procedure, "index" option} {
      list [catch {.t index @xyz} msg] $msg
  } {1 {bad text index "@xyz"}}
***************
*** 369,375 ****
      list [.t get 1.0 1.end] [.t tag ranges bold] [.t tag ranges silly]
  } {{First second} {1.0 1.5} {1.5 1.12}}
  
! # Mark, scan, search, see, tag, window, xview, and yview actions are tested elsewhere.
  
  test text-12.1 {ConfigureText procedure} {
      list [catch {.t2 configure -state foobar} msg] $msg
--- 371,377 ----
      list [.t get 1.0 1.end] [.t tag ranges bold] [.t tag ranges silly]
  } {{First second} {1.0 1.5} {1.5 1.12}}
  
! # Edit, mark, scan, search, see, tag, window, xview, and yview actions are tested elsewhere.
  
  test text-12.1 {ConfigureText procedure} {
      list [catch {.t2 configure -state foobar} msg] $msg
***************
*** 1365,1370 ****
--- 1367,1485 ----
      tkTextSetCursor .t 3.0
      .t search -backward -regexp "\$" insert 1.0
  } {2.6}
+ 
+ test text-25.1 {TextEditCmd procedure, argument parsing} {
+     list [catch {.t edit} msg] $msg
+ } {1 {wrong # args: should be ".t edit option ?arg arg ...?"}}
+ 
+ test text-25.2 {TextEditCmd procedure, argument parsing} {
+     list [catch {.t edit gorp} msg] $msg
+ } {1 {bad edit option "gorp": must be modified, redo, reset, separator or undo}}
+ 
+ test text-25.3 {TextEditUndo procedure, undoing changes} {
+     catch {destroy .t}
+     text .t -undo 1
+     pack .t
+     .t insert end "line 1\n"
+     .t delete 1.4 1.6
+     .t insert end "should be gone after undo\n"
+     .t edit undo
+     .t get 1.0 end
+ } "line\n\n"
+ 
+ test text-25.4 {TextEditRedo procedure, redoing changes} {
+     catch {destroy .t}
+     text .t -undo 1
+     pack .t
+     .t insert end "line 1\n"
+     .t delete 1.4 1.6
+     .t insert end "should be back after redo\n"
+     .t edit undo
+     .t edit redo
+     .t get 1.0 end
+ } "line\nshould be back after redo\n\n"
+ 
+ test text-25.5 {TextEditUndo procedure, resetting stack} {
+     catch {destroy .t}
+     text .t -undo 1
+     pack .t
+     .t insert end "line 1\n"
+     .t delete 1.4 1.6
+     .t insert end "should be back after redo\n"
+     .t edit reset
+     catch {.t edit undo} msg
+     set msg
+ } "nothing to undo"
+ 
+ test text-25.6 {TextEditCmd procedure, insert separator} {
+     catch {destroy .t}
+     text .t -undo 1
+     pack .t
+     .t insert end "line 1\n"
+     .t edit separator
+     .t insert end "line 2\n"
+     .t edit undo
+     .t get 1.0 end
+ } "line 1\n\n"
+ 
+ test text-25.7 {-autoseparators configuration option} {
+     catch {destroy .t}
+     text .t -undo 1 -autoseparators 0
+     pack .t
+     .t insert end "line 1\n"
+     .t delete 1.4 1.6
+     .t insert end "line 2\n"
+     .t edit undo
+     .t get 1.0 end
+ } "\n"
+ 
+ test text-25.8 {TextEditCmd procedure, modified flag} {
+     catch {destroy .t}
+     text .t
+     pack .t
+     .t insert end "line 1\n"
+     .t edit modified
+ } {1}
+ 
+ test text-25.9 {TextEditCmd procedure, reset modified flag} {
+     catch {destroy .t}
+     text .t
+     pack .t
+     .t insert end "line 1\n"
+     .t edit modified 0
+     .t edit modified
+ } {0}
+ 
+ test text-25.10 {TextEditCmd procedure, set modified flag} {
+     catch {destroy .t}
+     text .t
+     pack .t
+     .t edit modified 1
+     .t edit modified
+ } {1}
+ 
+ test text-25.11 {<<Modified>> virtual event} {
+     set ::retval unmodified
+     catch {destroy .t}
+     text .t -undo 1
+     pack .t
+     bind .t <<Modified>> "set ::retval modified"
+     update idletasks
+     .t insert end "nothing special\n"
+     set ::retval
+ } {modified}
+ 
+ test text-25.12 {<<Selection>> virtual event} {
+     set ::retval no_selection
+     catch {destroy .t}
+     text .t -undo 1
+     pack .t
+     bind .t <<Selection>> "set ::retval selection_changed"
+     update idletasks
+     .t insert end "nothing special\n"
+     .t tag add sel 1.0 1.1
+     set ::retval
+ } {selection_changed}
  
  eval destroy [winfo child .]
  option clear
Only in try/tk8.4a2/unix: Makefile
Only in try/tk8.4a2/unix: config.cache
Only in try/tk8.4a2/unix: config.log
Only in try/tk8.4a2/unix: config.status
Only in try/tk8.4a2/unix: tkConfig.sh
diff -c -r orig_2/tk8.4a2/unix/tkUnixDefault.h try/tk8.4a2/unix/tkUnixDefault.h
*** orig_2/tk8.4a2/unix/tkUnixDefault.h	Fri Jul 28 18:34:55 2000
--- try/tk8.4a2/unix/tkUnixDefault.h	Sat Jul  7 19:46:05 2001
***************
*** 409,414 ****
--- 409,415 ----
   * Defaults for texts:
   */
  
+ #define DEF_TEXT_AUTO_SEPARATORS	"1"
  #define DEF_TEXT_BG_COLOR		NORMAL_BG
  #define DEF_TEXT_BG_MONO		WHITE
  #define DEF_TEXT_BORDER_WIDTH		"2"
***************
*** 443,448 ****
--- 444,450 ----
  #define DEF_TEXT_STATE			"normal"
  #define DEF_TEXT_TABS			""
  #define DEF_TEXT_TAKE_FOCUS		(char *) NULL
+ #define DEF_TEXT_UNDO    		"0"
  #define DEF_TEXT_WIDTH			"80"
  #define DEF_TEXT_WRAP			"char"
  #define DEF_TEXT_XSCROLL_COMMAND	""
diff -c -r orig_2/tk8.4a2/win/tkWinDefault.h try/tk8.4a2/win/tkWinDefault.h
*** orig_2/tk8.4a2/win/tkWinDefault.h	Fri Jul 28 18:34:56 2000
--- try/tk8.4a2/win/tkWinDefault.h	Sat Jul  7 19:46:57 2001
***************
*** 414,419 ****
--- 414,420 ----
   * Defaults for texts:
   */
  
+ #define DEF_TEXT_AUTO_SEPARATORS	"1"
  #define DEF_TEXT_BG_COLOR		"SystemWindow"
  #define DEF_TEXT_BG_MONO		WHITE
  #define DEF_TEXT_BORDER_WIDTH		"2"
***************
*** 448,453 ****
--- 449,455 ----
  #define DEF_TEXT_STATE			"normal"
  #define DEF_TEXT_TABS			""
  #define DEF_TEXT_TAKE_FOCUS		(char *) NULL
+ #define DEF_TEXT_UNDO    		"0"
  #define DEF_TEXT_WIDTH			"80"
  #define DEF_TEXT_WRAP			"char"
  #define DEF_TEXT_XSCROLL_COMMAND	""
