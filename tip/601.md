# TIP 601: "encoding convertto/convertfrom" option to stop on error
	Author:         Harald Oehlmann <harald.oehlmann@elmicron.de>
	State:          Draft
	Type:           Project
	Vote:           Pending
	Tcl-Version:    8.7
	Tcl-Branch:     encodings-with-flags
-----
# Abstract

An additional option is proposed for `encoding convertto/convertfrom` to stop on the first encoding issue.

# Rationale

The command `encoding convertfrom/convertto` currently does not raise any error on not convertable input.
Instead the following actions are observed:

   *   A replacement character `?` is used.
   *   An incomplete multi-byte sequence is added verbatim.

## Example 1: not encodable character

The Polish character "L with bar" is not contained in ISO-latin 1:

    % set s \u0141
    Ł
    % encoding convertto iso8859-1 $s
    ?

In the ISO-Latin 1 conversion, it is replaced by a question mark by the `encoding convertto` command.

## Example 2: Incomplete sequence returns remaining value verbatim

The following utf-8 sequence has an incomplete final sequence.
The second byte of the two byte sequence of the last character is missing.
The incomplete sequence is interpreted as ISO8859-1 and added to the string.

     % set s [encoding convertfrom utf-8 [string range [encoding convertto utf-8 ÄÖ] 0 end-1]]
     ÄÃ
     % scan $s %c%c
     196 195

The first character value 196 is the correct "Ä" character.
The second character is the verbatim byte of the incomplete utf-8 sequence:

     % scan [encoding convertto utf-8 Ö] %c%c
     195 150

## Use case 1: decode continuous multi-byte data


My personal use-case is a stream of UTF-8 data which is received by a USB character driver and the binary data is cut in 64 byte chunks.
The stream is continuous and I want to decode the received data.
If a UTF-8 byte is received partly, a false byte is created and the next chunk decoding does not work, as it starts with a part of a UTF-8 multibyte sequence.

It would be great to know, where the error is to stop the sequence.

Here is a code snipped with the current implementation:

    % catch {encoding convertfrom utf-8 -stoponerror 1 [string range [encoding convertto utf-8 ÄÖ] 0 end-1]} e d
    1
    % set d
        -code 1\
        -level 0
        -errorstack {INNER {invokeStk1 ::tcl::encoding::convertfrom -stoponerror 1 utf-8 Ã\x84Ã }}
        -errorcode {TCL ENCODING STOPONERROR 2}
        -errorinfo {conversion error at index 2
            while executing
            "encoding convertfrom -stoponerror 1 utf-8 [string range [encoding convertto utf-8 ÄÖ] 0 end-1]"} -errorline 1

Remark "\0x84" was replaced for the control character "IND" for visibility in the stack trace

With this info, the `-errorcode` may be catched by a `try` clause and the error byte location (2) may be catched.
The data before may by passed again to `encoding convertfrom` which is the correct received data.

Note: it would be efficient, if the already converted string may be returned also.
Then, the data must not be passed again to `encoding convertfrom`.
The current implementation does not fullfill this optimisation.

## Use case 2:

This use case is given in the following TCL ticket:
[Ticket 535705](https://core.tcl-lang.org/tcl/info/535705ffffffffff) :

Wrong characters are included in a data base by character replacement when a character not in the current system encoding.
This causes issues in a multi-platform applications, as the error is not detected.

# Specification

## New Option
The `encoding` ensamble will be extended by a new option `-stoponerror`:

    encoding convertfrom ?-stoponerror bool? ?encoding? data
    encoding convertto ?-stoponerror bool? ?encoding? data

The specified boolean has the following functionality:

| Value   | Description |
|:-------:|:----------------:|
| `FALSE` | Any conversion data error is handled by replacement by **?** of the concerned byte |
| `TRUE`  | The conversion stops with an error on any conversion data error |

The default value is `FALSE` for TCL 8.x and `TRUE` for TCL 9.x.

## Error reporting

If `-stoponerror` is `TRUE`, the following error reporting takes place in case of an conversion error.

### Definition of "error position"
The position of the error in the source string is indicated in the error reporting.
In case of multi-byte source data, this position is always one byte after the last correct multi-byte sequence.

###Error Message

The error message is: "conversion error at index *error position*"

where *error position* is a number containing the source string error position as defined above.

### Error Code

The error code is composed of the following 4 list elements:

1.  Fix word: `TCL`
2.  Fix word: `ENCODING`
3.  Fix word: `STOPONERROR`
4.  Value *error position*: The index in the source string of the error position.

# Discussion

## Ticket 535705

This TIP started in the [TCL ticket 535705](https://core.tcl-lang.org/tcl/info/535705ffffffffff).
Please refer to this ticket for information about the initial discussion.

## Option design

The requirement to use a boolean instead a flag is due to the fact, that it was proposed to change the default value from `FALSE` to `TRUE` with **TCL9**.
Otherwise, it is not possible to write code for **TCL8** and **TCL9**.
The boolean is not required if this default change is not seen as a possibility (it may be a vote option).

## Error reporting design

The list of categories for the error code return is given in the [tclvars manual page](http://www.tcl-lang.org/man/tcl8.7/TclCmd/tclvars.htm#M12).
The **TCL** category matches best.

This design allows to catch this error and get the error position by the following `try` pattern:

    try {
        set res [encoding convertto iso8859-1 $input]
    } trap {TCL ENCODING STOPONERROR} {errorMessage errorDict} {
        set errorIndex [lindex [dict get $errorDict -errorcode] 3]
        ...
    }

# Rejected alternatives

## Report the error character

The original implementation reported the failing character in the error message.
This may be a control character corrupting a terminal view.
IMHO error messages should be in the printable ASCII character set.
Thus, this reporting was removed.

The error character was also reported as hexadecimal byte.
This is IMHO of limited use.
In addition, only the byte was expressed.
But the error may be a multi-byte sequence like an invalid utf-8 sequence.
So, this is not always exact.

## Option at the end

For me, the option position at the end of the command looks difficult.
One may have a large expression as data and this option may just not be visible.
An example is as follows:

    % catch {encoding convertfrom utf-8 [string range [encoding convertto utf-8 ÄÖ] 0 end-1] -stoponerror 1} e d

IMHO options should be specified before the data.

# Implementation

Implementation is in Tcl branch `encodings-with-flags`

# Compatibility

Compatible

# Copyright

This document has been placed in the public domain.
