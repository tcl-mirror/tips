# TIP 601: "encoding convertto/convertfrom" option to stop on error
	Author:         Harald Oehlmann <harald.oehlmann@elmicron.de>
	State:          Draft
	Type:           Project
	Vote:           Pending
	Tcl-Version:    8.7
	Tcl-Branch:     encodings-with-flags
-----
# Abstract

An additional option is proposed for `encoding convertto/convertfrom` to stop on the first encoding issue.

# Rationale

The command `encoding convertfrom/convertto` currently does not raise any error on not convertable input.
Instead the following actions are observed:

   *   A replacement character `?` is used.
   *   An incomplete multi-byte sequence is added verbatim.

## Example 1: not encodable character

The Polish character "L with bar" is not contained in ISO-latin 1:

    % set s \u0141
    Ł
    % encoding convertto iso8859-1 $s
    ?

In the ISO-Latin 1 conversion, it is replaced by a question mark by the `encoding convertto` command.

## Example 2: Incomplete sequence returns remaining value verbatim

The following utf-8 sequence has an incomplete final sequence.
The second byte of the two byte sequence of the last character is missing.
The incomplete sequence is interpreted as ISO8859-1 and added to the string.

     % set s [encoding convertfrom utf-8 [string range [encoding convertto utf-8 ÄÖ] 0 end-1]]
     ÄÃ
     % scan $s %c%c
     196 195

The first character value 196 is the correct "Ä" character.
The second character is the verbatim byte of the incomplete utf-8 sequence:

     % scan [encoding convertto utf-8 Ö] %c%c
     195 150

## Use case 1: decode continuous multi-byte data


My personal use-case is a stream of UTF-8 data which is received by a USB character driver and the binary data is cut in 64 byte chunks.
The stream is continuous and I want to decode the received data.
If a UTF-8 byte is received partly, a false byte is created and the next chunk decoding does not work, as it starts with a part of a UTF-8 multibyte sequence.

It would be great to know, where the error is to stop the sequence.

Here is a code snipped with the current implementation:

    % catch {encoding convertfrom utf-8 [string range [encoding convertto utf-8 ÄÖ] 0 end-1] -stoponerror} e d
    1
    % set d
        -code 1\
        -level 0
        -errorstack {INNER {invokeStk1 ::tcl::encoding::convertfrom utf-8 Ã\x84Ã -stoponerror}}
        -errorcode {TCL ENCODING STOPONERROR 2}
        -errorinfo {unexpected byte at index 2: 'Ã' (\xC3)
            while executing
            "encoding convertfrom utf-8 [string range [encoding convertto utf-8 ÄÖ] 0 end-1] -stoponerror"} -errorline 1

Remark "\0x84" was replaced for the control character "IND" for visibility in the stack trace

With this info, the `-errorcode` may be catched by a `try` clause and the error byte location (2) may be catched.
The data before may by passed again to `encoding convertfrom` which is the correct received data.

Note: it would be efficient, if the already converted string may be returned also.
Then, the data must not be passed again to `encoding convertfrom`.
The current implementation does not fullfill this optimisation.

## Use case 2:

This use case is given in the following TCL ticket:
[Ticket 535705](https://core.tcl-lang.org/tcl/info/535705ffffffffff) :

Wrong characters are included in a data base by character replacement when a character not in the current system encoding.
This causes issues in a multi-platform applications, as the error is not detected.

# Specification


# Implementation

Implementation is in Tcl branch `encodings-with-flags`

# Compatibility

Compatible

# Copyright

This document has been placed in the public domain.
