# TIP 529: Add metadata dict property to tk photo image
    Author:         Harald Oehlmann <oehhar@users.sourceforge.net>
    State:          Draft
    Type:           Project
    Vote:           Pending
    Created:        07-Dec-2018
    Keywords:       Tk, image
    Tcl-Version:    8.7
    Tk-Branch:     tip-529-image-metadata
-----

# Abstract

An additional property is proposed for photo images to hold a dictionary with image metadata:

    myimage cget -metadata
    myimage configure -metadata [dict create DPI 300.0]

The content of the dictionary is initialized on image load and used on image save.

# Rationale

Image files may contain a lot of metadata like resolution, comments, GPS location etc.
This metadata should be accessible and setable for the following aims:

   *   Make it available after image load on script level
   *   Make it setable within the image
   *   Write its data to the image file.
   *   Optimize operations by storing intermediate image representations. Due to that, the metadata dict may be the 3rd source (beside -file and -data options) for image data.
   *   Pass additional data to the image format driver where the "-format" option extension is not suitable.

## image resolution

This TIP specially targets the resolution (DPI) value of the image.

The image resolution included in an image file is crucial for its usage, as many applications (word & co.) use this field to calculate a default size.
One may enjoy, that image files used in pdf4tcl are automatically scaled at the right resolution (e.g. the resolution saved in the image file).

This information is included in png files (supported by tk core) and many other image formats included in the Img patch.

I authored an extension to the Img patch to specify the dpi field of a bmp file on file writing. The syntax was accorded with Jeff Hobbs:

    myimage write file.bmp -format [list bmp -resolution 300 i]

This may be expressed (when all packages are adopted) by:

    myimage configure -metadata [dict create DPI 300.0]
    myimage write file.bmp

I was just contacted by Paul Obermaier (TkImg maintainer) to extend the upper patch to other image formats.
This motivated me again to work on the implementation.

## XMP data

Photo images may contain an XMP data structure which may hold structured data.
The aim is to make this data accessible.
The parsing of the XML structure is not part of this TIP and may be done by other packages.

## Intermediate Image representation

The TIP should set the base to hold an intermediate image representation (The concrete solution may follow by another TIP).

The application is within the current SVG implementation included in Tk8.7a3.

The used svg routines from the nanosvg project split svg processing into two steps:

   *   Step 1: transform the xml data to a binary representation of the splines
   *   Step 2: render the splines to an image presentation

When svg files are loaded by:

    image create photo i1 -file test.svg -format {svg -scaletoheight 16}

then the file is accessed and the xml data loaded and processing step 1 and 2 is performed.

When the image is scaled by:

    i1 configure -format {svg -scaletoheight 32}

then the same steps are performed as on image load, while only step 2 would be necessary.
The performance is poor and the file must still be available.

The idea is to store the binary representation of the splines (result of processing step 1) as a key in the **-metadata** dict (say splinesblob) and to acheve to only perform step 2 on scaling.

In addition, svg image may even be "compiled" to the metadata structure, so the following command may work:

    image create i1 -metadata {splineblob ...} -format {svg -scaletoheight 32}

This will only work within the same patchlevel of TK, as the format may change, but it may be useful for example when packing to a starkit.

In my talk on ETCL 2019, I showed an Android GUI where buttons may be scaled by a pinch to zoom gesture. The current performance is quite poor.

## Comment data

A comment may be used to save custom data in the image file.

An example is a vision automation project where a test procedure is connected to each image.
My solution is to use GIF images and to store the test procedure (a TCL script) in the gif comment.


## Extended image format driver interface

Additional possibilities in the image driver interface are proposed:

   *   A DString memory may be used by the match procedure to pass data to the read procedure
   *   The file match procedure may flag that the file read procedure will not need the file any more.

The rationale for both are the current implementation of the SVG driver:

   *   The driver currently uses ThreadSpecific data to pass data from the match procedure to the read procedure. Due to that, a more simple alternate possibility is proposed
   *   The driver does not need the file any more after the match procedure. Thus, any preparing file operations (seek etc) may be omitted and a NULL channel may be passed.

## Preview extension for new command "image find"

The match functions should also be able to output the metadata dict.
This is due to the plan by Paul Obermeier to make the match function alone available on the script level.
See the discussion section for the message.
# Specification

## Metadata Dict

The propery "**-metadata**" is added to each image.  It contains a dictionary,
where the keys of the dictionary are specific to each photo image format.

The following default keys are used by Tk's built in photo image formats, if the
corresponding data is present:

| Key       | Description      | Example image formats |
|:---------:|:----------------:|:---------------------:|
| `DPI`     | Horizontal Image resolution in DPI (double) | png                   |
| `aspect`  | Aspect ratio horizontal/vertical (double)   | gif                   |
| `comment` | Text comment     | gif                   |
| `XMP`     | xmp image data   | gif,png               |

Comments on the key choice:

   *   Abreviation are in capital letters
   *   Words are in Americal English in English (small) case
   *   Vertical DPI is expressed as DPI/aspect. The reason is, that some image formats only feature aspect and no dpi.

If a particular image does not specify any keys (whether during creation or
otherwise) then the dictionary will be empty.

Each photo image format driver may define additional keys and may decide to use them for input (as a parameter for image read and/or image write), output (as an image read result) or both.

The TIP implementation does not target to implement all possible keys of all image formats for reading and writing imediately.
Image key format may grow over time on a use-case basis.

## Commands

The following commands are extended by a -metadata parameter:

    image create photo myimage -metadata $metadict
    myimage cget -metadata
    myimage configure -metadata $metadict
    myimage data -metadata $metadict
    myimage put -metadata $metadict
    myimage read -metadata $metadict
    myimage write -metadata $metadict

It is also OK to store application data related to the image within the
property dict.
A widget may store special properties.
Any function reading the metadata dict will ignore unknown keys.

Any image format handler may use the content of the metadata dict.  This may
be an ongoing process, specially within the Img patch.

Here is an overview, which command reads or sets the metadata dict:

| Command | Reads current image metadata dict | reads command options metadata dict | Writes current image metadata dict |
| :-: | :-: | :-: | :-: |
|: image create :|: no :|: yes :|: yes :|
|: myimage cget :|: yes :|: no :|: no :|
|: myimage configure :|: yes :|: yes :|: no :|
|: myimage put :|: no :|: yes :|: no :|
|: myimage read :|: no :|: yes :|: no :|
|: myimage data :|: no :|: yes :|: no :|
|: myimage write :|: yes :|: yes :|: no :|

### image create

Image create will parse the image data and create the metadata dict of the image.

As an example, a gif file with a comment would create a comment metadata key within the image:

    % image create photo myimage -format GIF -file testwithcomment.gif
    % myimage cget -metadata
    Comment "This is the image comment"

A metadata dict given on the command line will be merged with the parsed metadata dict with priority to the file metadata.

An example with the same image as above:

    % image create photo myimage -format GIF -file testwithcomment.gif\
       -metadata [dict create User A Comment "Comment from command line"]
    % myimage cget -metadata
    User A Comment "This is the image comment"

The command line metadata dict may be used to specify "pre-compiled" image data.

As a example, the spline blob of an svg is saved and used to create another image:

   image create photo myimage -format SVG -file "test.svg"
   set splineblobdata [dict get [myimage cget -metadata] SplineBlob]

   image create photo myotherimage -format SVG -metadata [dict create SplineBlob $splineblobdata]

### myimage cget

The metadata dict may be retrieved by:

    myimage cget -metadata

### myimage configure

The metadata dict of the image may be overwritten by:

    myimage configure -metadata [dict create Comment "Comment from cconfigure"]

The image data is not touched and no image data interpretation is triggered.

The retrival methods will return the metadata dict as for any other option:

    % myimage configure -metadata
    -metadata {} {} {} {Comment "Current comment"}

Setting the -format, -data or -file option will recreate the image with the new parameters.
In this case, an eventually present -metadata option will first replace the present metadata of the image.
Then, the image recreation will take place (eventually using the metadata) and may add keys to the image metadata dict.

It is not possible to trigger an image recreation by just specifying a metadata dict.

### myimage put

The put command sets (parts of) the image data by specified new image data.

The -metadata property of the image is not changed.
The reason for that is that the purpose of this command is that only parts of the image are replaced.
Other options specified to the put command, like the -data property or an eventual -format option do not change the current property values neither.
To replace the whole image including metadata, the configure command may be used by setting the -data option.

Example with gif data containing a comment:

    % image create myimage -metadata [dict create Comment "Comment from image create"]
    % myimage put $GIFWithCommentData
    % myimage cget -metadata
    Comment "Comment from image create"

A -metadata option may be specified to support the image read. Nevertheless, this metadata is not included in the metadata property of the image.

Example:

    % image create myimage -metadata [dict create Comment "Comment from image create"]
    % myimage put $GIFWithCommentData -metadata [dict create Comment "Comment from put command line"]
    % myimage cget -metadata
    Comment "Comment from image create"

Example with used metadata image data

    % image create myimage
    % myimage put "" -format SVG -metadata [dict create SplineBlob $splineblobdata]

## myimage read

The read command sets (parts of) the image data by new image data read from a file.
This command acts like the put command with the difference, that the image data comes from a file.

It is not possible to use image data from the -metadata command dict, as a file must be specified, which can not be omitted.

The -metadata property of the image is not changed.
The reason for that is that the purpose of this command is that only parts of the image are replaced.
Other options specified to the put command, like the -file and an eventual -format option do not change the current property values neither.
To replace the whole image including metadata, the configure command may be used by setting the -file option.

Example with a gif file containing a comment:

    % image create myimage -metadata [dict create Comment "Comment from image create"]
    % myimage read gifwithcomment.gif
    % myimage cget -metadata
    Comment "Comment from image create"

A -metadata option may be specified to support the image read. Nevertheless, this metadata is not included in the metadata property of the image. There is currently no practical application for this, but there might be examples which use that.

Example:

    % image create myimage -metadata [dict create Comment "Comment from image create"]
    % myimage read test.gif -metadata [dict create Comment "Comment from put command line"]
    % myimage cget -metadata
    Comment "Comment from image create"

## myimage data

The data command writes the image data into a variable.

If the image formats supports metadata, it is included in the output file.

If a -metadata option is given, the metadata property of the image is ignored.
Otherwise, the metadata property of the image is used.

Example to write a comment in gif data included in the image properties:

    % image create myimage -file test.png -metadata [dict create Comment "Comment from image create"]
    % myimage data -format "GIF"
    ... GIF data with comment included

Example to specify the comment with the command options

    % image create myimage -file test.png
    % myimage data -format "GIF"-metadata [dict create Comment "Comment from data command"]
    ... GIF data with comment included

## myimage write

The write command writes the image data to a file.
With respect to metadata, it works the same way as the data command.

Example to write a metadata comment:

    % image create myimage -file test.png
    % myimage write GifwithComment.gif -format "GIF"-metadata [dict create Comment "Comment from write command"]
    ... GIF data with comment included

# Image format driver interface

The image format driver interface is changed in the following aspects:

## Pass metadata dict as parameter

Each driver function gets a tcl object pointer "metadataIn" as parameter.
This parameter serves to input a metadata dict to the driver function.
It may be NULL to flag that the metadata dict is empty.

A typical driver code snipped to check for a metadata key is:

    if (NULL != metadataIn) {
        Tcl_Obj *itemData;
        Tcl_DictObjGet(interp, metadataIn, Tcl_NewStringObj("Comment",-1), &itemData));


## Receive a metadata dict from the driver

The image match and read functions (FileMatch, StringMatch, FileRead, StringRead) may set keys in a prepared metadata dict to return them.
Those function get an additional tcl object pointer as "metadataOut" as parameter.

This parameter may be NULL to indicate, that no metadata return is attended (put, read subcommands).

This parameter is initialized to an empty unshared dict object if metadata return is attended (image create command, configure subcommand).
The driver may set dict keys in this object to return metadata.

A sample driver code snippet is:

    if (NULL != metadataOut) {
        Tcl_DictObjPut(NULL, metadataOut, Tcl_NewStringObj("XMP",-1), Tcl_NewStringObj(xmpMetadata);


## match and read function communication memory

The match functions and the image read functions get an additional parameter "driverInternalPtr" which points to an initialized DString.
The DString is cleared by the framework.

Using this DString, the driver match function may pass data to its read function.

## flag that the match function does not need the channel any more

The driver file match function may flag, that it does not need the channel any more.
Only in this case, the additional output int "closeChannel" should be set to 1.
In this case, a NULL driver is passed to the read driver function.

## Image format driver interface

For image format drivers, a new registration procedure is proposed which includes functions with the new parameters.
In addition, the parameters are reordered to always have the order interp, input parameter, output parameter, accillary functions.

The new stubs enabled function is:

    void Tk_CreatePhotoImageFormatVersion3(const Tk_PhotoImageFormatVersion3 *formatPtr)

The function parameters in Tk_PhotoImageFormatVersion3 are as follows:

	int (Tk_ImageFileMatchProcVersion3) (Tcl_Interp *interp, Tcl_Channel chan,
		const char *fileName, Tcl_Obj *format, Tcl_Obj *metadataIn, int *widthPtr,
		int *heightPtr, Tcl_Obj *metadataOut, int *closeChannelPtr,
		Tcl_DString *driverInternalPtr);

	int (Tk_ImageStringMatchProcVersion3) (Tcl_Interp *interp, Tcl_Obj *dataObj,
		Tcl_Obj *format, Tcl_Obj *metadataIn, int *widthPtr, int *heightPtr,
		Tcl_Obj *metadataOut, Tcl_DString *driverInternalPtr);

	int (Tk_ImageFileReadProcVersion3) (Tcl_Interp *interp, Tcl_Channel chan,
		const char *fileName, Tcl_Obj *format, Tcl_Obj *metadataIn,
		Tk_PhotoHandle imageHandle,
		int destX, int destY, int width, int height, int srcX, int srcY,
		Tcl_Obj *metadataOut, Tcl_DString *driverInternalPtr);

	int (Tk_ImageStringReadProcVersion3) (Tcl_Interp *interp, Tcl_Obj *dataObj,
		Tcl_Obj *format, Tcl_Obj *metadataIn, Tk_PhotoHandle imageHandle,
		int destX, int destY, int width, int height, int srcX, int srcY,
		Tcl_Obj *metadataOut, Tcl_DString *driverInternalPtr);

	int (Tk_ImageFileWriteProcVersion3) (Tcl_Interp *interp, const char *fileName,
		Tcl_Obj *format, Tcl_Obj *metadataIn, Tk_PhotoImageBlock *blockPtr);

	int (Tk_ImageStringWriteProcVersion3) (Tcl_Interp *interp, Tcl_sObj *format,
		Tcl_Obj *metadataIn, Tk_PhotoImageBlock *blockPtr);

# Implementation

Implementation started with the tag tip-529-image-metadata.

Thanks to Paul Obermaier, the TkImg package has implemented the new interface and uses it currently for DPI setting and reporting.

A set of test cases is included in the implementation.
In addition, the TkImg package features additional tests for this patch which exercise additional features like stub table, image parameters.

# Rejected Alternatives

# Discussion

## image find command planned by Paul Obermeier

What about extending and exposing the functionality of the MatchProc function at the Tcl level?
That way it would be possible to implement a command like "image info <fileName>", where
you can retrieve the image size, resolution and additional metadata without explicitely loading
the image.
In my image browser (http://www.posoft.de/html/poImgBrowseShots.html#Img1)
I am currently using a modified version of the Tcllib fileutil::fileType procedure to extract the
image size without creating a photo image. Getting that information (and additional metadata)
directly from the C-based image parsers would be faster and there would be no need to code that
functionality twice.

HaO: This functionality is prepared by the possibility that the match driver functions also may output metadata.

## Update DPI metadata property on image script

Paul Obermeier has made the following proposal:

How do you want to handle the physical resolution (DPI) in the case of image scaling?
Just keep the original DPI value or adjust the DPI values automatically, maybe using an option.

HaO: Currently, this is not prevued and may be implemented by another TIP.

# Copyright

This document has been placed in the public domain.
