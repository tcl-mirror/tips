TIP:            171
Title:          Change Default <MouseWheel> Bindings Behavior
Version:        $Revision: 1.3 $
Author:         Jeff Hobbs <jeffh@activestate.com>
Author:         Keith Vetter <kvetter@alltel.net>
State:          Draft
Type:           Project
Vote:           Pending
Created:        05-Mar-2004
Post-History:   
Tcl-Version:    8.5

~ Abstract

This TIP proposes changing the default <MouseWheel> bindings in Tk to
have "better" behaved defaults for a larger set of applications.

~Rationale 

The existing <MouseWheel> bindings only operate on a small handful of
widgets, and only when they have focus.  This essentially means that
only the text widget ever has useful <MouseWheel> behavior.  This is
not how the majority of applications wish to use the MouseWheel.  They
operate primarily on a mouse-focus model (scroll what the mouse is
over, not what has [[focus]]).

~ Specification 

The bindings changes are very simply these:

|proc ::tk::MouseWheel {wFired D X Y} {
|    # do not double-fire in case the class already has a binding
|    if {[bind [winfo class $wFired] <MouseWheel>] ne ""} { return }
|    # obtain the window the mouse is over
|    set w [winfo containing $X $Y]
|    # if we are outside the app, try and scroll the focus widget
|    if {![winfo exists $w]} { catch {set w [focus]} }
|    if {[winfo exists $w]} {
|	 # scrollbars have different call conventions
|	 if {[winfo class $w] eq "Scrollbar"} {
|	     catch {tk::ScrollByUnits $w \
|			[string index [$w cget -orient] 0] \
|			[expr {-($D/30)}]}
|	 } else {
|	     catch {$w yview scroll [expr {- ($D / 120) * 4}] units}
|	 }
|    }
|}
|bind all <MouseWheel> [list ::tk::MouseWheel %W %D %X %Y]
|if {[tk windowingsystem] eq "x11"} {
|    # Support for mousewheels on Linux/Unix commonly comes through
|    # mapping the wheel to the extended buttons.
|    bind all <4> [list ::tk::MouseWheel %W 120 %X %Y]
|    bind all <5> [list ::tk::MouseWheel %W -120 %X %Y]
|}

Instead of requiring a widget to have [[focus]] to receive MouseWheel
events, the new proposal operates with MouseWheel as a global binding.
When fired, it first does a safety check to prevent double-firing if
an existing MouseWheel binding is on the widget.  It then finds the
widget which the mouse if over and uses that as the target for the
scrolling event.  If that widget doesn't exist (usually meaning that
it returned {} indicating we are outside the Tk app), then use the
widget which has the actual [[focus]].

In scrolling, the scrollbar must be treated separately, since it has
its own calling conventions.  All others widgets get called with the
standard yview scroll command, caught in case of errors, which are
ignored.

This has been discussed on the tcl-mac mailing list already as the
desired behavior, and confirmed to be more intuitive on Windows as
well.  The above code is already in use by applications that use
widget extensions and megawidgets such as BWidgets without any adverse
effects seen.  Note that the existing MouseWheel bindings must first
be removed, using the following code:

|set mw_classes [list Text Listbox Table TreeCtrl]
|foreach class $mw_classes { bind $class <MouseWheel> {} }
|if {[tk windowingsystem] eq "x11"} {
|    foreach class $mw_classes {
|	 bind $class <4> {}
|	 bind $class <5> {}
|    }
|}

~ Reference Implementation 

See above.

~ Discussion

Two quick comments. First I've found it very nice if 
shift-MouseWheel scrolls horizontally. Second, tile's
combobox widget should have its class binding removed.
It has, however, yet another different scrolling calling
convention which will need to be handled specifically.

Another tile work-around is that you have to modify
the class test to also recognize TScrollbar with 
something like 
|  if {[string match "*Scrollbar" [winfo class $w]]} ...

~ Copyright 

This document has been placed in the public domain.
