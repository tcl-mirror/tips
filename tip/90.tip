TIP:            90
Title:          Enable [return -code] in Control Structure Procs
Version:        $Revision: 1.13 $
Author:         Don Porter <dgp@users.sf.net>
Author:         Donal K. Fellows <fellowsd@cs.man.ac.uk>
State:          Draft
Type:           Project
Vote:           Pending
Created:        15-Mar-2002
Post-History:   
Tcl-Version:    8.4

~ Abstract

This TIP analyzes existing limitations on the coding of control
structure commands as ''proc''s, and presents expanded forms of
''catch'' and ''return'' to remove those limitations.

~ Background

It is a distinguishing feature of Tcl that everything is a command,
including control structure functionality that in many other languages
are part of the language itself, such as ''if'', ''for'', and
''switch''.  The command interface of Tcl, including both a return
code and a result, allows extensions to create their own control
structure commands.

Control structure commands have the feature that one or more of their
arguments is a script, often called a ''body'', meant to be evaluated
in the caller's context.  The control structure command exists to
control whether, when, in what context, or how many times that script
is evaluated.  When the body is evaluated, however, it is intended to
behave as if it were interpreted directly in the place of the control
structure command.

The built-in commands of Tcl provide the ability for scripts
themselves to define new commands.  Notably, the ''proc'' command
makes this possible.  In addition, other commands such as ''catch'',
''return'', ''uplevel'', and ''upvar'' offer enough control and access
to the caller's context that it is possible to create new control
structure commands for Tcl, entirely at the script level.

Almost.

There is one limitation that separates control structure commands
created by ''proc'' from those created in C by a direct call to
''Tcl_Create(Obj)Command''.  It is most easily seen in the following
example that compares the built-in command ''while'' to the command
''control::do'' created by ''proc'' in the control package of tcllib.

|  % package require control
|  % proc a {} {while 1 {return -code error}}
|  % proc b {} {control::do {return -code error} while 1}
|  % catch a
|  1
|  % catch b
|  0

The control structure command ''control::do'' fails to evaluate
''return -code error'' in such a way that it acts the same as if
''return -code error'' was evaluated directly within proc ''b''.

~ Analysis

There are two deficiencies in Tcl's built-in commands that lead to
this incapacity in control structure commands defined by ''proc''.

First, ''catch'' is not able to capture the information.  Consider:

|   %  set code [catch {
|          return -code error -errorinfo foo -errorcode bar baz
|      } message]

After evaluation, ''code'' contains "2" (''TCL_RETURN''), ''message''
contains "baz", ''::errorInfo'' contains "foo", and ''::errorCode''
contains "bar".  But there is nothing accessible at the script level
that contains the value passed to the ''-code'' option.  That code is
stored internally in the ''Tcl_Interp'' structure as
''interp->returnCode'', but scripts cannot access that value.

Second, even if the information were available, there is no built-in
command in Tcl that can be evaluated within the body of a proc to make
the proc itself act as if it were the command ''return -code''.
Stated another way, it is not possible to create a command with
''proc'' that behaves exactly the same as ''return -code''.  Because
of that, it is also not possible to create a command with ''proc''
that behaves exactly the same as ''while'', ''if'', etc. - any
command that evaluates any of its arguments as a script in the
caller's context.

This is a curious, and likely unintentional, limitation.  Tcl goes to
great lengths to be sure I can create my own ''break'' replacement
with ''proc''.

| proc myBreak {} {return -code break}

It would be a welcome completion of Tcl's set of built-in commands to
be able to create a replacement for every one of them using ''proc''.

~ Specification

The ''return'' command shall have syntax:

| return ?option value ...? ?result?

There can be any number of ''option value'' pairs, and
any value at all is acceptable for an ''option'' argument.
The legal values of a ''value'' argument are limited for
some ''option''s, as follows:

 > the ''value'' after a "-code" must be either
   an integer (32-bit only), or one of the strings, "ok",
   "error", "return", "break", or "continue",
   just as in the 8.4 spec for ''return''.  The default ''value''
   for the "-code" option is "0".

 > the ''value'' after a "-level" must be a non-negative integer.
   The default ''value'' for the "-level" option is "1".

 > the ''value'' after a "-options" must be a dictionary ([111]).
   The default ''value'' for the "-options" option is an empty
   dictionary.

The keys and values in the dictionary ''value'' of the -options
option are pulled out and treated as additional ''option value''
arguments to the ''return'' command.  Note that this "-options" option
for option expansion is offered only because Tcl itself has no
syntax for argument expansion, as observed many, many times before.

The ''result'' argument, if any, is stored in the interp as the
result of the ''return'' command.  In default operation, this
becomes the result of the procedure in which the ''return'' command
is evaluated.

The return code of the ''return'' command is determined by the
''value''s of the "-code" and "-level" options.  If the ''value''
of the "-level" option is non-zero, then the return code of
''return'' is TCL_RETURN.  If the ''value'' of the "-level" option
is "0", then the return code of ''return'' is the ''value'' of the
"-code" option, translated from string, as needed.  In this way,

| return -level 0 -code break

is a synonym for

| break

while

| return -code break

spelled out with defaults filled in as:

| return -level 1 -code break

continues to function as before, causing the procedure in which
the ''return'' is evaluated to return the TCL_BREAK return code.

All ''option value'' arguments to ''return'' are stored in a
return options dictionary kept in the interp, just as the
''result'' argument gets stored in the result of the interp.

The TclUpdateReturnInfo() function is modified, so that each
level of procedure returning decrements the value of the "-level"
key in thre return options dictionary.  When the value of the
"-level" key reaches "0", the return code from the current procedure
will be the value of the "-code" key in the return options dictionary.
Otherwise, the return code of the current procedure will be TCL_RETURN.

In this way,

| return -level 2 -code ok

is equivalent to

| return -code return

and should (absent some intervening ''catch'') cause a normal return
to the caller's caller.  Likewise,

| return -level 3 -code ok

would cause a normal return to the caller's caller's caller, something
that can't currently be accomplished (again absent an intervening
''catch'').

~ Examples

~ Prototype

This proposal is implemented by Tcl Patch 531640 at SourceForge.

The prototype covers all described functionality, but might be
further improved with more substantial bytecompiling of [return].

~ Future considerations

::errorInfo and ::errorCode could go away...

''bgerror'' improvements.

~ Acknowledgments

This proposal is a synthesis of ideas from many sources.  As best
I can recall, major contributions came from Joe English, Andreas
Leitgeb, and Kevin Kenny.  If you like the idea, give them some
credit; it you don't, blame me for combining the ideas badly.

~ See also

Documentation for tcllib's control package: 
http://tcllib.sf.net/doc/control.html

~ Copyright

This document has been placed in the public domain.
