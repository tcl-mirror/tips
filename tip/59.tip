TIP:		59
Title:		Embed Build Information in Tcl Binary Library
Author:		Andreas Kupries <andreas_kupries@users.sourceforge.net>
Version:	$Revision: 1.1 $
Type:		Project
State:		Draft
Vote:		Pending
Tcl-Version:	8.4
Created:	04-Sep-2001
Post-History:	

~ Abstract

This TIP provides an interface through which Tcl may be queried for
information on its own compilation flags and requirements, in order to
extract the information directly instead of reading it from a Bourne
shell file.  An important reason to do this is to have the information
not only available but also tightly bound to the binary configured by
it, so that the information doesn't get lost.

~ Foreword

This TIP proposes a rather small change to Tcl and tries very hard to
follow the KISS principle. Given that the casual observer might find
it rather long, be assured, the actual specification in here is not
very long, nor complicated. Most of the following explanations were
added to preserve the KISS principle and head off attempts to extend
the TIP beyond its small goal and scope.

Note: All instances of "Tcl library" in the following text refer to
the generated installable library and not the script library coming
with the core.

~ Background and Rationale

The main reason for writing this TIP are the disadvantages inherent in
the current way of storing the configuration of Tcl, namely in the file
''tclConfig.sh''.

   * It is a separate file, easily lost or not installed at all,
     making it difficult for extension developers to access this
     information.

   * The name does not convey that ''tclConfig.sh'' contains platform
     and build specific information. When installing different builds
     this usually leads to clashes. This makes it again difficult for
     extension developers to find the right file for their current build.

   * Not every extension generates such a file for use by other
     extensions.

Thus, this TIP proposes:

   * an extension of the public API so that extensions are able to
     define configuration arrays and to fill them during
     initialization with the information embedded into their
     installable libraries during compilation.

   * to embed the information about the compilation environment of the
     Tcl library as strings into the generated installable library and
     make them accessible at the script level through Tcl variables,
     thus allowing developers on any platform Tcl compiles on to
     access this information.

The file ''tclConfig.sh'' is ''not'' replaced by this system, both
sets of information exist in parallel.

~ Interface Specification

Any embedded information is made accessible at the Tcl level through a
read-only array variable. The variable used by Tcl itself is
''::tcl::config''. Extensions have to use their own array
variables. These variables will be named ''config'' too and have to be
placed within in the namespaces owned by the extensions initializing
them.

At the C-level the public API of the Tcl core is extended with a
single function to register the embedded configuration information.
This function is added to the public stub table of the Tcl core so
that it can be used by Tcl and extensions to register their own
configuration information in the system during initialization.

The function takes two (2) arguments; first, the name of the package
registering its configuration information and second, a pointer to an
array of structures. Each element of the array refers to two strings
containing the key and the value associated with that key. The end of
the array is signalled by an empty key.

Formalized, name and signature of this new function are

| Tcl_RegisterConfig (CONST char* pkgName, Config* configuration)
|
| typedef struct Config {
|    char* key;
|    char* value;
| }

Both strings are expected in ASCII. This choice is undesirable for
i18n, but I currently see no other way because I don't know how to
convert the strings generated by ''configure'' (on Unix platform) into
UTF-8 without the aid of an existing Tcl installation and its tclsh.

The function will

   * create a namespace having the provided ''pkgName'', if not yet existing.

   * create the array variable ''config'' in that namespace and link it
     to the provided information so that the keys from
     ''configuration'' appear as keys in the array, with their
     associated values.

~ How to Gather the Embedded Information

The information to be embedded is gathered in a platform-specific way.

   * Under unix it is determined primarily by the existing
     ''configure'' script and written into the file
     ''tclUnixConfig.c'' (from a template ''tclUnixConfig.c.in''). The
     configuration information coming from the Makefile, or from other
     compile time means, is embedded into the tclUnixConfig.c file by
     means of preprocessor statements (#ifdef ... #endif).

   * For the Windows and Mac platforms volunteers have to create a
     file ''tclWinConfig.c.some-ext'' containing this information for
     each supported build environment, like VC++, Borland, Cygwin,
     etc.

   > ''tclWinConfig.c.vc'' = VC++.

   > ''tclWinConfig.c.bc'' = Borland.

   > ''tclWinConfig.c.in'' = Cygwin. ''.in'' is used because Cygwin
     can use configure to determine the values and embed them into a
     template.

   * As for other platforms, these are handled either like Unix or
     like Mac, depending on the availability and usability of
     ''configure''.

   > Volunteers are required to write the appropriate files for their
     build environment.


~ Specification of Tcl Configuration Information

The configuration information registered by Tcl itself is specified
here. A discussion of the choices made here follows in the next
section. Please read this discussion before commenting on the
specification.

The values associated with the keys below are all of one of the
following types:

   * Boolean flag. Allowed values are all the values which are
     accepted by Tcl itself. Examples are:

|	true, false, on, off, 1, 0

   * String. General container for all other information.

   * Templated string. With respect to placeholders in the same format
     as 'Script' below, but does not have to be a valid Tcl script.

   * Script. A string containing a full Tcl script. The user should
     handle this string like a procedure body. The script is allowed
     to contain placeholders to be filled by the user of the string.
     Placeholders follow the syntax of full-braced Tcl variables,
     i.e. ''${some_name}'. The actual values can be filled in by the
     user of the configuration information. Possible ways to do so are
     [regsub], [string map] or [subst -nocommand]. The best way
     however would be to use the script as a procedure body, with the
     placeholders as the arguments of the procedure. This will avoid
     many problems regarding bracing and the protection of special
     characters.

   > Which placeholders are possible for a particular script or
     template is described together with the meaning of the key.

   > Beyond the placeholders a script or templated string is allowed
     to contain references to other values in the ''config''
     array. These references use the same variable syntax as the
     placeholders.

The registered keys follow below. They will be always present with
some value. Non-boolean keys not applicable to a particular platform
will contain the empty string as their value.

   * Configuration of Tcl itself:

   >   * ''debug''. Boolean flag. Set to false if Tcl was not compiled
         to contain debugging information.

   >   * ''threaded''. Boolean flag. Set to false if Tcl was not
         compiled as thread-enabled.

   >   * ''profiled''. Boolean flag. Set to false if Tcl was not
         compiled to contain profiling statements.

   >   * ''64bit''. Boolean flag. Set to false if Tcl was not compiled
         in 64bit mode.

   >   * ''optimized''. Boolean flag. Set to false if Tcl was compiled
         without compiler optimizations.

   >   * ''mem_debug''. Boolean flag. Set to false if Tcl has no
         memory debugging compiled into it.

   >   * ''compile_debug''. Boolean flag. Set to false if Tcl has no
         bytecode compiler debugging compiled in.

   >   * ''compile_stats''. Boolean flag. Set to false if Tcl has no
         bytecode compiler statistics compiled in.

   >   * ''library,dependencies''. String. Contains the flags required
         to pick up all the libraries the Tcl library itself depends
         upon.

   * Installation configuration of Tcl. In other words, various
     important locations.

   >   * ''prefix,runtime''.  String. The directory for platform
	 independent files as seen by the interpreter during runtime.

   >   * ''exec_prefix,runtime'' String. The directory for platform
         dependent files as seen by the interpreter during runtime.

   >   * ''prefix,install''. String. The directory for platform
         independent files as seen by the installer at install-time.

   >   * ''exec_prefix,install''. String. The directory for platform
         dependent files as seen by the installer at install-time.

   * Platform specific compilation configuration of Tcl. Commands and
     information to compile and link files, the required flags, etc.

   >   * ''compile,c''. Script. Contains a script executing all the
         necessary commands which are required to compile a C source
         file into an object file for the platform.

   >   > Example of contents for Unix platforms having ''gcc'':

|		set srcfile [file nativename [file join ${srcpath} ${file}.c]]
|		set objfile [file nativename [file join ${dstpath} \
|			${file}${::tcl::config(obj,ext)}]]
|		exec gcc -o $objfile -fPIC $srcfile

   >   > Example of contents for Win* employing VC++

|	... to be written ...		TODO ...

   >   > Note that the commands do not have to execute the tools
	 directly.  They could also start an IDE or write an IDE
	 specific configuration file. It all depends on the written
	 configuration.

   >   > The following configuration references are allowed in the script:

   >   >   * ${::tcl::config(obj,ext)}

   >   > The following placeholders are allowed in the compile script.
         All of them contain platform specific information (for
         example path separators).

   >   >   * ''${file}''. String. The base-name of the file to be
             compiled, without extension.

   >   >   * ''${srcpath}''. String. The location of the source file,
             i.e the directory it can be found in.

   >   >   * ''${dstpath}''. String. The intended location of the
             object file, i.e. the directory it is placed in after its
             generation. 

   >   >   * ''${defs}''. String. A Tcl list containing additional
             macro definitions required for the compilation, one
             element per macro definition. This may allow extensions
             to insert their own definitions after the definitions set
             by Tcl itself. Note that the declaration of these
             definitions has to be done by the extension in an
             platform independent way. The result of these
             declarations will be platform dependent however.

   >   >   * ''${inc}''. String. A Tcl list containing additional
             preprocess arguments to pick up additional include
             directories required for the compilation, one element per
             new include path. This may allow extensions to insert
             their own paths before the paths set by Tcl itself. Like
             for ''${defs}'' the elements of the list are platform
             dependent in itself, but will be declared by extensions
             in a platform independent manner.

   >   * ''link,shlib''. Script. Contains a script executing all the
         necessary commands which are required to link several object
         files into a shared library.

   >   > Example for Unix platforms

|		eval exec gcc -shared -o lib${libname}${libversion}.so \
|			${requiredlibs} ${objects}

   >   > Example for Win* platforms

|		TODO

   >   > The following placeholders are employed in the link script:

   >   >   * ''{libname}''. The base-name of the library created by the
             command.
    
   >   >   * ''${libversion}''. The version of the shared library
             created by the command.
    
   >   >   * ''${objects}''. A string containing the full paths to all
             object files linked into the library.
    
   >   >   * ''${requiredlibs}''. All links flags which are required
             to find and pick the libraries the generated library is
             dependent upon.

   >   * ''link,stlib''. Script. Contains a script executing all the
         necessary commands which are required to link several object
         files into a static library. Employs the same placeholders as
         ''link,shlib''.

   >    * ''link,app''. Script. Contains a script executing all the
          necessary commands which are required to link several object
          files and libraries into an application.

   >   > Example for Unix platforms

|		eval exec gcc -rdynamic -o {appname}${appversion} \
|			-Wl,-rpath,${searchdir} ${requiredlibs} \
|			${objects}

   >   > Example for Win* platforms

|		TODO

   >   > The following placeholders are employed in the link script:

   >   >   * ''{appname}''. The base-name of the application created by
             the command.

   >   >   * ''${appversion}''. The version of the application created
             by the command.

   >   >   * ''${objects}''. A string containing the full paths to all
             object files linked into the application.

   >   >   * ''${requiredlibs}''. All links flags which are required
             to find and pick the libraries the generated application
             is dependent upon.

   >   >   * ''${searchdir}''. String containing the directory to look
             in for the shared libraries, like libtcl, linked into the
             application.

   >   * ''shlib,ext''. String. Contains the file extension for shared
         libraries on the platform, including the dot.

   >   > Example for Unix platforms:

|		.so

   >   > Example for Win* platforms:

|		.dll

   >   * ''stlib,ext''. String. Contains the file extension for static
         libraries on the platform, including the dot.

   >   > Example for Unix platforms:

|		.a

   >   > Example for Win* platforms:

|		.lib

   >   * ''obj,ext''. String. Contains the file extension for object
         files on the platform, including the dot.

   >   > Example for Unix platforms:

|		.o

   >   > Example for Win* platforms:

|		.obj

   >   * ''exp,ext''. Templated string. Contains the file extension
         for export files on the platform, including the dot.
         Platforms not requiring export files may place the empty
         string into this item.

   >   > The only allowed placeholder is ''${version}'', denoting
	 where to place version information.

   >   > Example:

|		${version}.exp

   >   * ''shlib,name,full''. Templated string. Defines how the full
         name of a shared library file is constructed.

   >   > The names of the respective stub libraries can be constructed
	 using ''stlib,name,*'' and ${libname}stub as the name of the
	 library.

   >   > Example for Unix systems expecting the version before the
         extension (libtcl8.4.so)

|		lib${libname}${libversion}${tcl::config(shlib,ext)}	

   >   > Example for Unix systems expecting the version after the
         extension (libtcl.so.8.4)

|		lib${libname}${tcl::config(shlib,ext)}.${libversion}

   >    > Example for Win* platform (tcl84.dll). It is 84 instead
          8.4. because on Win* ''link,version-usage'' is set to
          "nodots".

|		${libname}${libversion}${tcl::config(shlib,ext)}

   >   > The following placeholders and configuration references are
         employed:

   >   >   * ''${libname}''. The base-name of the library.

   >   >   * ''${libversion}''. The version of the library.

   >   >   * ''${tcl::config(shlib,ext)}''. The file extension to use
             for the shared library.

   >   * ''shlib,name,short''. Templated string. Defines how the short
         name of a shared library file is constructed. The short name
         is the one used in a link flag to pick up the library

   >   > Example for Unix platforms (tcl8.4)

|		${libname}${libversion}

   >   > The following placeholders and config references are employed:

   >   >   * ''${libname}''. The base-name of the library.

   >   >   * ''${libversion}''. The version of the library.

   >   >   * ''${tcl::config(shlib,ext)}''. The file extension to use
             for the shared library.

   >   * ''stlib,name,full''. Templated string. Defines how the full
         name of a static library file is constructed. Uses the same
         placeholders as ''shlib,name,full'', but uses a reference to
         ''stlib,ext''.

   >   * ''stlib,name,short''. Templated string. Defines how the short
         name of a static library file is constructed. Uses the same
         placeholders as ''shlib,name,short'', but uses a reference to
         ''stlib,ext''.

   >   * ''link,version-usage''. String. Possible values are ''ok'',
         ''nodots'' and ''no''. Indicates whether version numbers
         should be used in -l switches. The value "ok" means it's safe
         to use switches like -ltcl7.5; "nodots" means you have to use
         switches like -ltcl75). SunOS and FreeBSD require "nodots",
         for example.

   >   > To be used when compiling an extension to determine how to
	 construct the version strings to insert into the various
	 templates from the actual version number of the extension.

   >   * ''link,shlib,need-export''. Boolean flag. Indicates whether
         shared libraries need export files on the platform. Set to
         false if they don't.

   >   * ''link,shlib,need-dependencies''. Boolean flag. Indicates
         whether the libraries the extension depends on have to be
         included when linking shared libraries. Set to false if they
         don't have to be included.

~ Discussion

The placement of this information into a separate package was proposed
but rejected because of the trouble of finding the right information
for the right library in the case of multiple configurations installed
into the same directory space.  Embedding into the library does not
cost much space and binds the information tightly to the right spot.

Another reason to do it this way is that this enables us to embed
information coming from the Makefile itself (like ''MEM_DEBUG'') or
from other compile time means. This would not be possible for a file
generated solely by the Tcl configure. It would also restrict the
embedding to the platforms which allow the use of ''configure''
script.

The usage of a separate package to just access the information placed
into the Tcl library was also proposed. This was rejected too, due to
the overhead for the management of the package in comparison to the
small size of the code actually involved.

Another proposal rejected in the early discussions was to have this
TIP define an entire build system based upon Tcl. This TIP is
certainly a step in this direction and facilitates the building of
such a build system (sic!). Still, specifying such here was seen as
too large a step right now, with too many issues to be solved and thus
delaying the implementation of this TIP.

Only the configuration of the particular variant of the Tcl library or
extension which was generated is recorded in the library. No attempt
is made to record the information required to allow the compilation of
any possible variant of an extension. Doing so would reach again into
the bigger topic of specifying a full build system. We've already
established that as being out of the intended scope of this TIP.

Note further that the scheme as specified above does not prevent us
from adding the full information in a later stage. In other words, it
does not restrict the development of a more powerful system in the
future.

This should be enough reasoning to allow the acceptance of even this
admittedly simple system.

The configuration information registered by Tcl bears a semblance to
the information in ''tclConfig.sh'' but is not identical. Instead of
providing only small pieces of information which have to be assembled
(in a platform-dependent way) by the user of the information to be
actually useful (like in ''tclConfig.sh'') the embedded information
provides larger components nearly complete for use in actions like the
compilation of a single source file. There are no current plans to add
this information to ''tclConfig.sh''.

If an extension requires more information than provided by the Tcl
configuration it will have to obtain this information itself. For
instance, TclBlend requires a CLASSPATH, the name of a Java compiler,
etc. whereas the TclPython and TclPerl extensions require paths to
those environments, etc. It is not reasonable that the configure
script for Tcl itself have to accommodate all requirements of all
extensions of Tcl.  Instead, the configure scripts or whatever other
means is used to obtain the configuration information for the
extensions should reflect their needs, and register the requirements
gathered into their own configuration array. Note that an extension is
only expected to create variables for information unique to
it. Everything else can be had from the configuration array of Tcl and
the extensions it depends on.

This TIP is not in opposition to [34] but rather fleshes out one of
the many details in the specification which were left open by that
TIP.

This TIP also does not propose to change the process for building Tcl
itself. The goal is rather to make the building of extensions easier
in the future.

A naming convention for keys in the ''config'' array would have been
possible but would also require quite a lot more text, both in careful
definition of the general categories and in explanations of the
choices made.


~ Example

The example below shows how the information could be used and should
under no circumstances be seen as a proposal made by this TIP on how
to define higher level functionality in a build environment to be.

| proc compile    {file srcpath dstpath defs inc} \
|	 $::tcl::config(compile,c)
| proc linkshared {libname libversion requiredlibs objects} \
|	 $::tcl::config(link,shlib)
| proc linkstatic {libname libversion requiredlibs objects} \
|	 $::tcl::config(link,stlib)
| proc linkapp    {appname appversion objects requiredlibs searchdir} \
|	 $::tcl::config(link,app)
|
| set defs [list [def BAR 854u43] [def baz "X Y"]]
|
| foreach src {pad drawing} {
|    compile $src . . $defs {}
|    lappend objects $src$::tcl::config(obj,ext)
| }
| compile fooStubInit . . $defs {}
|
| linkshared foo     [version 0.1] {} $objects
| linkstatic foostub [version 0.1] {} fooStubInit$::tcl::config(obj,ext)

~ Copyright

This document is in the public domain.
