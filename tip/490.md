# TIP 490: msgcat for tcloo
	Author:         Harald Oehlmann <oehhar@sourceforge.com>
	State:          Draft
	Type:           Project
	Vote:           Pending
	Created:        07-Dec-2017
	Post-History:
	Keywords:       msgcat, oo
	Tcl-Version:    8.7
-----

# Abstract

Package **msgcat** implements message catalogues for packages organized in nested namespaces.
This TIP defines an extension for TCLOO.

# Rationale

Since TCLOO was included in the core, packages may also be defined as TCLOO classes.
The **msgcat** package should feature an extension to support this.

(anything below this point provided by Donal Fellows in the core list thread "msgcat enhancement")
A package should have its methods within a package namespace:

<pre>
namespace eval ::foo {
    oo::class create Foo
    oo::class create Bar
}
package provide foo 1.0
</pre>

The message catlog belongs to the package, not to an individual class.

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create Foo {
        # ...
    }
    oo::class create Bar {
        # ...
    }
}
package provide foo 1.0
</pre>

# Documentation

Each class which wants to use message catalogs require a call to `mixin msgcat::MessageCatalogAware`.

Then, the catalog of the package namespace is available with the `mc` command

# Examples

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create Foo {
        mixin msgcat::MessageCatalogAware
        # ...
    }
    oo::class create Bar {
        mixin msgcat::MessageCatalogAware
        # ...
    }
}
package provide foo 1.0
</pre>

# Implementation

Donal Fellows proposed two solutions in the thread started by René.

The implementation is as follows:

<pre>
namespace eval ::msgcat {
   oo::class create MessageCatalogAware {
      forward mc       ::msgcat::OOBridge ::msgcat::mc
      forward mcmax    ::msgcat::OOBridge ::msgcat::mcmax
      forward mcexists ::msgcat::OOBridge ::msgcat::mcexists
      # Tricky point: methods are not usefully callable from outside the class hierarchy
      unexport mc mcmax mcexists
   }

   proc OOBridge {cmd args} {
      if {[catch {
         # Tricky point: [self class] needs to run in the caller
         set ns [namespace qualifiers [uplevel 1 {self class}]]
      }]} {
         # Not a class-defined method (so we got an error); use instance instead
         set ns [namespace qualifiers [uplevel 1 self]]
      }
      tailcall apply [list {cmd args} {tailcall $cmd {*}$args} $ns] $cmd
   }
}
</pre>

This is contained in the tcl fossil repository with tag [tip490-msgcat-oo](https://core.tcl.tk/tcl/timeline?r=tip490-msgcat-oo).

# Alternatives

## Use namespace of the caller

Proposed by René Zaumseil in tclcore post "msgcat enhancement" 2017-12-16 17:11 UTC.

msgcat::mc will translate messages with respect to the calling namespace.
In case of tcloo methods we will be called in the namespace of the object.
I propose to use instead the namespace of the class.

To do this we have to change the following line in the msgcat::mc procedure:

<pre>
set ns [uplevel 1 [list ::namespace current]]
</pre>

to also check for classes:

<pre>
if {[catch {set ns [uplevel 1 self class]}]} {
  set ns [uplevel 1 [list ::namespace current]]
}
</pre>

Message catalog files can then use the class namespace.

Here is an example:

<pre>
package req msgcat
# patch msgcat::mc
proc msgcat::mc {src args} {
    # this may be replaced by:
    # return [mcget -namespace [uplevel 1 [list ::namespace current]] --\
    #             $src {*}$args]

    # Check for the src in each namespace starting from the local and
    # ending in the global.

    variable Msgs
    variable Loclist

    if {[catch {set ns [uplevel 1 [list self class]]}]} {
               set ns [uplevel 1 [list ::namespace current]]
    }
    set loclist [PackagePreferences $ns]

    set nscur $ns
    while {$nscur != ""} {
                foreach loc $loclist {
                    if {[dict exists $Msgs $nscur $loc $src]} {
                               return [DefaultUnknown "" [dict get $Msgs $nscur $loc $src]\
                                               {*}$args]
                    }
                }
                set nscur [namespace parent $nscur]
    }
    # call package local or default unknown command
    set args [linsert $args 0 [lindex $loclist 0] $src]
    switch -exact -- [Invoke unknowncmd $args $ns result 1] {
                0 { return [uplevel 1 [linsert $args 0 [namespace origin mcunknown]]] }
                1 { return [DefaultUnknown {*}$args] }
                default { return $result }
    }
}
# test locale
::msgcat mclocale de

# *.msg files:
namespace eval :: {::msgcat::mcmset de {
  {english} {german}
  {bla} {Bla}
}}
namespace eval ::A {::msgcat::mcmset de {
  {english} {A german}
  {bla} {A Bla}
}}

# *.tcl files:
oo::class create A {
  method p {} {puts [::msgcat::mc {english}]=[::msgcat::mc {bla}]}
}
proc p {} {puts [::msgcat::mc {english}]=[::msgcat::mc {bla}]}

# test
p
A create a1; a1 p
</pre>

## Use own commands for getting and setting message catalogues

Eric Boudallier proposed a solution on [Wiki page "msgcat and TclOO"](http://wiki.tcl.tk/39430)

There is also an addendum by Donal Fellows how to implement this is smaller way.

## mixin solution where superclass and subclass may not be in different namespaces:

Donal Fellows also provided this solution.

The key then is how to make `msgcat::mc` work (and a few related commands as well). The trick I've thought of is to use the magic powers of `apply` and `tailcall`; here's what we're looking for:

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create MessageCatalogAware {
        forward mc apply {args {tailcall ::msgcat::mc {*}$args} ::foo}
        unexport mc
    }
    oo::class create Foo {
        mixin MessageCatalogAware
        # ...
    }
    oo::class create Bar {
        mixin MessageCatalogAware
        # ...
    }
}
package provide foo 1.0
</pre>

(I'd use a mixin for this; it's not really about the class itself; it's just about making a capability available.)

It'd be nice to have a way to make that bridging class automatically. Here it is.

<pre>
oo::class create ::msgcat::oobridge {
    superclass oo::class
    self method create {name args} {
        set cls [next $name {*}$args]
        set ns ::[namespace qualifiers [namespace which $cls]]
        foreach cmd {mc mcmax mcexists} {
            oo::define $cls forward $cmd apply [list \
                {cmd args} {tailcall $cmd {*}$args} $ns] \
                ::msgcat::$cmd
            oo::define $cls unexport $cmd
        }
        return $cls
    }
}
</pre>

Now our little package would become:

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    msgcat::oobridge create MessageCatalogAware
    oo::class create Foo {
        mixin MessageCatalogAware
        # ...
    }
    oo::class create Bar {
        mixin MessageCatalogAware
        # ...
    }
}
package provide foo 1.0
</pre>

Alternatively, we could plug the capabilities into `oo::define`; the principles of the code are largely the same but the details are little different.

I've been thinking about this more, and I've realised that there is a subtle problem: a superclass and a subclass could be in different namespaces in different packages, and so could reasonably want to use different message catalogs. This means that the bridging code always needs to look up what the context namespace is at runtime, which in turn means that there's no need for clever class manufacturing, and it can all be done with (see chpter "Implementation" above).

# Copyright

This document has been placed in the public domain.

