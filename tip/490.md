# TIP 490: msgcat for tcloo
	Author:         Harald Oehlmann <oehhar@sourceforge.com>
	State:          Draft
	Type:           Project
	Vote:           Pending
	Created:        07-Dec-2017
	Post-History:
	Keywords:       msgcat, oo
	Tcl-Version:    8.7
-----

# Abstract

Package **msgcat** implements message catalogues for packages organized in nested namespaces.
This TIP defines an extension for TCLOO.

# Rationale

Since TCLOO was included in the core, packages may also be defined as TCLOO classes.
The **msgcat** package should feature an extension to support this.

A package should have its methods within a package namespace:

<pre>
namespace eval ::foo {
    oo::class create Foo
    oo::class create Bar
}
package provide foo 1.0
</pre>

The message catlog belongs to the package, not to an individual class.

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create Foo {
        # ...
    }
    oo::class create Bar {
        # ...
    }
}
package provide foo 1.0
</pre>

# Documentation

Each class which wants to use message catalogs require a call to `mixin msgcat::MessageCatalogAware`.

Then, the following commands are available and correspond to the msgcat:: commands:

* my mc
* my mcmax
* my mcexists

All other mc-commands are not available within classes and should be used outside of a class.

# Examples

Within the following example, the message pcatalog for the package is loaded outside the method definitions.

A class "Foo" is created and the msgcat capabilities are activated by the mixin.

Then, a method is defined, which uses the message catalog of the namespace.

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create Foo {
        mixin msgcat::MessageCatalogAware
        method printMessage {x y} {
            puts [my mc "FooPrintMessage(%d,%d)" $x $y]
        }
    }
}
package provide foo 1.0
</pre>

# Implementation

Donal Fellows proposed two solutions in the thread started by René.

The implementation is in tcl fossil in branch
[tip490-msgcat-oo](https://core.tcl.tk/tcl/timeline?r=tip490-msgcat-oo).

# Alternatives

## Use namespace of the caller

Proposed by René Zaumseil in tclcore post "msgcat enhancement" 2017-12-16 17:11 UTC.

msgcat::mc will translate messages with respect to the calling namespace.
In case of tcloo methods we will be called in the namespace of the object.
I propose to use instead the namespace of the class.

To do this we have to change the following line in the msgcat::mc procedure:

<pre>
set ns [uplevel 1 [list ::namespace current]]
</pre>

to also check for classes:

<pre>
if {[catch {set ns [uplevel 1 self class]}]} {
  set ns [uplevel 1 [list ::namespace current]]
}
</pre>

Message catalog files can then use the class namespace.

## Use own commands for getting and setting message catalogues

Eric Boudallier proposed a solution on [Wiki page "msgcat and TclOO"](http://wiki.tcl.tk/39430)

There is also an addendum by Donal Fellows with an alternate implementation.

## mixin solution where superclass and subclass may not be in different namespaces:

Donal Fellows also provided this solution.

The key then is how to make `msgcat::mc` work (and a few related commands as well). The trick I've thought of is to use the magic powers of `apply` and `tailcall`; here's what we're looking for:

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create MessageCatalogAware {
        forward mc apply {args {tailcall ::msgcat::mc {*}$args} ::foo}
        unexport mc
    }
    oo::class create Foo {
        mixin MessageCatalogAware
        # ...
    }
    oo::class create Bar {
        mixin MessageCatalogAware
        # ...
    }
}
package provide foo 1.0
</pre>

(I'd use a mixin for this; it's not really about the class itself; it's just about making a capability available.)

It'd be nice to have a way to make that bridging class automatically. Here it is.

<pre>
oo::class create ::msgcat::oobridge {
    superclass oo::class
    self method create {name args} {
        set cls [next $name {*}$args]
        set ns ::[namespace qualifiers [namespace which $cls]]
        foreach cmd {mc mcmax mcexists} {
            oo::define $cls forward $cmd apply [list \
                {cmd args} {tailcall $cmd {*}$args} $ns] \
                ::msgcat::$cmd
            oo::define $cls unexport $cmd
        }
        return $cls
    }
}
</pre>

Now our little package would become:

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    msgcat::oobridge create MessageCatalogAware
    oo::class create Foo {
        mixin MessageCatalogAware
        # ...
    }
    oo::class create Bar {
        mixin MessageCatalogAware
        # ...
    }
}
package provide foo 1.0
</pre>

Alternatively, we could plug the capabilities into `oo::define`; the principles of the code are largely the same but the details are little different.

I've been thinking about this more, and I've realised that there is a subtle problem: a superclass and a subclass could be in different namespaces in different packages, and so could reasonably want to use different message catalogs. This means that the bridging code always needs to look up what the context namespace is at runtime, which in turn means that there's no need for clever class manufacturing, and it can all be done with (see chpter "Implementation" above).

# Credits

* René Zaumseil: initiative
* Eric Boudallier: alternate implementation
* Donal Fellows: implementation and examples


# Copyright

This document has been placed in the public domain.

