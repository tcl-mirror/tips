# TIP 490: msgcat for tcloo
	Author:         Harald Oehlmann <oehhar@sourceforge.com>
	State:          Draft
	Type:           Project
	Vote:           Pending
	Created:        07-Dec-2017
	Post-History:
	Keywords:       msgcat, oo
	Tcl-Version:    8.7
-----

# Abstract

Package **msgcat** implements message catalogues for packages organized in nested namespaces.
This TIP proposes the extension to TclOO.

# Rationale

Since TCLOO was included in the core, packages may also be defined as TCLOO classes or classless objects.
The **msgcat** package should feature this.

A package should have its methods within a package namespace:

<pre>
namespace eval ::foo {
    oo::class create Foo
}
package provide foo 1.0
</pre>

The message catlog belongs to the package, not to an individual class.

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create Foo {
        # ...
    }
}
package provide foo 1.0
</pre>

# Documentation

There are 3 use-cases to consider (which may be intermixed in the same package):

(with 'Servus!' as translation for 'Hi!')

## Use-Case 1: the package does not use OO

<pre>
namespace import msgcat::*
namespace eval ::N1 {
    mcload $dir/msgs
    proc m1 {} {
        puts [mc Hi!]
    }
}

% N1::m1
Servus!
</pre>

## Use-case 2: The package implementation is done by a class

<pre>
namespace import msgcat::*
namespace eval ::N2Class {
    mcload $dir/msgs
    oo::class create C1
    oo::define C1 method m1 {
        puts [mc Hi!]
    }
}

# The class object may be used in another namespace
namespace eval ::N2Obj {
    set O1 [::N2Class::C1 new]
}

% $N2Obj::O1 m1
Servus!
</pre>

## Use-case 3: The package implementation is done by a classless object

<pre>
namespace import msgcat::*
namespace eval ::N3 {
    mcload $dir/msgs
    oo::object create O2
    oo::objdefine O2 method m1 {} {
        puts [mc Hi!]
    }
}

% N3::O2 m1
Servus!
</pre>

# Usage

There are two extensions proposed:

## Extend all msgcat commands to support all 3 use-cases.

So any **msgcat** command will detect the scenario on its own and extract the package namespace automatically.

The commands which are packet-namespace related are: **mc**, **mcexists**, **mcpackagelocale**, **mcforgetpackage**, **mcpackagenamespaceget** (new command, see below), **mcpackageconfig**, **mcset** and **mcmset**.

This has the following advantages (compared to the alternatives):

* no new commands, no learning
* if another foreign procedure is called and the procedure wants to use the callers message catalog, it may just use "uplevel 1 {msgcat tag}" and does not need to know if it is a class or not.

Here is an example for the second advantage:

The tklib package "tooltip" may invoke "msgcat::mc msg" for all textes to get eventual translations (it does something like that but I don't understand it, IMHO broken).
The package namespace of the caller should be used (not the one of the tooltip package).

So:
<pre>
proc ::tooltip::tooltip {widget message} {
    ...
    set message [uplevel 1 {::msgcat::mc $message}]
}
</pre>

This will work in all use-cases, e.g. if tooltip::tooltip is called by a method following use-case 1 to 3.

## new command to get package namespace

The "magic" to extract the package namespace is exposed by the command:

<pre>
mcpackagenamespaceget
</pre>

This may be used:

* for the same case like the upper tooltip example, but for late binding
* for introspection and debugging

The upper tooltip example, where the translation is extracted when the tooltip is actually shown (to show an updated message if the current locale changed)

<pre>
proc ::tooltip::tooltip {widget message} {
    ...
    set messagenamespace [uplevel 1 {::msgcat::mcpackagenamespaceget}]
}

proc ::tooltip::show {widget messagenamespace message} {
    ...
    set message [namespace eval $messagenamespace [list ::msgcat::mc $message]]
}
</pre>

Examples with the 3 use-cases:

## Use-case 1: the package does not use OO

<pre>
namespace eval ::N1 {
    proc m1 {} {msgcat::mcpackagenamespaceget}
}

% N1::m1
::N1
</pre>

## Use-case 2: The package implementation is done by a class

namespace eval ::N2Class {
    oo::class create C1
    oo::define C1 method m1 {msgcat::mcpackagenamespaceget}
}

# The class object may be used in another namespace
namespace eval ::N2Obj {
    set O1 [::N2Class::C1 new]
}

% $N2Obj::O1 m1
::N2Class
</pre>

## Use-case 3: The package implementation is done by a classless object

<pre>
namespace eval ::N3 {
    oo::object create O2
    oo::objdefine O2 method m1 {} {msgcat::mcpackagenamespaceget}
}

% N3::O2 m1
::N3
</pre>

# Implementation

Within **msgcat**, the package namespace is currently extracted by:

<pre>
proc msgcat::mc {src args} {
    ...
    set ns [uplevel 1 {namespace current}]
</pre>

This is replaced by:

<pre>
proc msgcat::mc {src args} {
    ...
    set ns [PackageNamespaceGet]
    ...
}
proc ::msgcat::PackageNamespaceGet {} {
    uplevel 2 {
        # Check for no object
        # (undocumented test proposed by dkf 2018-01-12)
        if { [namespace which self] ne "::oo::Helpers::self"} {
            return [namespace current]
        }
        # Get Class
        set Class [info object class [self]]
        # Check for a classless object
        if {$Class eq {::oo::object}} {
            return [namespace qualifiers [self]]
        }
        # Object defined by class
        return [namespace qualifiers $Class]
    }
}
</pre>

The implementation is in tcl fossil in branch
[tip490-msgcat-oo-2](https://core.tcl.tk/tcl/timeline?r=tip490-msgcat-oo-2).

# Discussion

## Issue 1: are really all oo use-cases covered ?

Gosts like multiple inheritance, mixins, filters whatever are calling...

## Issue 2: performance loss

There is a performance penalty due to the modification described in "implementation".

To not decrease performance would require to introduce new commands, what I think is not good.

There is another idea of a low-level command: **mcn namespace key args** which does the final work of **mc**.
Then, the namespace may be cached and passed each time as argument.

In addition, this is useful if called by a foreign context, like from C or a foreign package (like the upper tooltip example or the wizard package).

Nevertheless, I would leave this for another TIP.

# Alternatives

## Use a mixin

Proposed by Donal Fellows

Each class which wants to use message catalogs require a call to `mixin msgcat::MessageCatalogAware`.

Then, the following commands are available and correspond to the msgcat:: commands:

* my mc
* my mcmax
* my mcexists

All other mc-commands are not available within classes and should be used outside of a class.

# Examples

Within the following example, the message catalog for the package is loaded outside the method definitions.

A class "Foo" is created and the msgcat capabilities are activated by the mixin.

Then, a method is defined, which uses the message catalog of the namespace.

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create Foo {
        mixin msgcat::MessageCatalogAware
        method printMessage {x y} {
            puts [my mc "FooPrintMessage(%d,%d)" $x $y]
        }
    }
}
package provide foo 1.0
</pre>

The implementation is in tcl fossil in branch
[tip490-msgcat-oo](https://core.tcl.tk/tcl/timeline?r=tip490-msgcat-oo).

## Use namespace of the caller

Proposed by René Zaumseil in tclcore post "msgcat enhancement" 2017-12-16 17:11 UTC.

msgcat::mc will translate messages with respect to the calling namespace.
In case of tcloo methods we will be called in the namespace of the object.
I propose to use instead the namespace of the class.

To do this we have to change the following line in the msgcat::mc procedure:

<pre>
set ns [uplevel 1 [list ::namespace current]]
</pre>

to also check for classes:

<pre>
if {[catch {set ns [uplevel 1 self class]}]} {
  set ns [uplevel 1 [list ::namespace current]]
}
</pre>

Message catalog files can then use the class namespace.

## Use own commands for getting and setting message catalogues

Eric Boudallier proposed a solution on [Wiki page "msgcat and TclOO"](http://wiki.tcl.tk/39430)

There is also an addendum by Donal Fellows with an alternate implementation.

## mixin solution where superclass and subclass may not be in different namespaces:

Donal Fellows also provided this solution.

The key then is how to make `msgcat::mc` work (and a few related commands as well). The trick I've thought of is to use the magic powers of `apply` and `tailcall`; here's what we're looking for:

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    oo::class create MessageCatalogAware {
        forward mc apply {args {tailcall ::msgcat::mc {*}$args} ::foo}
        unexport mc
    }
    oo::class create Foo {
        mixin MessageCatalogAware
        # ...
    }
    oo::class create Bar {
        mixin MessageCatalogAware
        # ...
    }
}
package provide foo 1.0
</pre>

(I'd use a mixin for this; it's not really about the class itself; it's just about making a capability available.)

It'd be nice to have a way to make that bridging class automatically. Here it is.

<pre>
oo::class create ::msgcat::oobridge {
    superclass oo::class
    self method create {name args} {
        set cls [next $name {*}$args]
        set ns ::[namespace qualifiers [namespace which $cls]]
        foreach cmd {mc mcmax mcexists} {
            oo::define $cls forward $cmd apply [list \
                {cmd args} {tailcall $cmd {*}$args} $ns] \
                ::msgcat::$cmd
            oo::define $cls unexport $cmd
        }
        return $cls
    }
}
</pre>

Now our little package would become:

<pre>
namespace eval ::foo {
    msgcat::mcload $dir/msgs
    msgcat::oobridge create MessageCatalogAware
    oo::class create Foo {
        mixin MessageCatalogAware
        # ...
    }
    oo::class create Bar {
        mixin MessageCatalogAware
        # ...
    }
}
package provide foo 1.0
</pre>

Alternatively, we could plug the capabilities into `oo::define`; the principles of the code are largely the same but the details are little different.

I've been thinking about this more, and I've realised that there is a subtle problem: a superclass and a subclass could be in different namespaces in different packages, and so could reasonably want to use different message catalogs. This means that the bridging code always needs to look up what the context namespace is at runtime, which in turn means that there's no need for clever class manufacturing, and it can all be done with (see chpter "Implementation" above).

# Credits

* René Zaumseil: initiative
* Eric Boudallier: alternate implementation
* Donal Fellows: implementation and examples
* Ashok P. Nadkarni: teach me oo by his excellent book


# Copyright

This document has been placed in the public domain.

