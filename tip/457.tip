TIP:            457
Title:          Add Support for Named Arguments
Version:        $Revision: 1.7 $
Author:         Mathieu Lafon <mlafon@gmail.com>
State:          Draft
Type:           Project
Vote:           Pending
Created:        21-Nov-2016
Post-History:   
Keywords:       Tcl,procedure,argument handling
Tcl-Version:    8.7

~ Abstract

This TIP proposes an enhancement of the Tcl language to support named
arguments when calling a procedure.

~ Rationale

The naming of arguments to procedures is a computer language feature which
allow developers to specify the name of an argument when calling a function.
This is especially useful when dealing with arguments with default values, as
this does not require to specify all previous arguments when only one argument
is required to be specified.

As such, this is a commonly requested feature by Tcl developers, who have
created various code snippets [http://wiki.tcl.tk/10702] to simulate it. These
snippets have drawbacks: not intuitive for new users, require to add extra
code at the start of each procedure, no standard on the format to use, few
errors handling, etc.

The following requirements have been taken into consideration for this
proposed feature:

 * must not break any existing program or package;

 * should work with existing procedures for this feature to be easily used
   with external packages;

 * should be consistent with the current syntax and usage of the Tcl
   language.

The others possibilities discussed with the community are detailed in the
''Discussion'' section at the end of the document.

The current proposal defines a new builtin command, named '''call''',
which can be used to call a Tcl-pure procedure with arguments specified with 
an ''-option value'' syntax, with or without starting positional arguments.
This command must not be confused with the '''eval''' command which has
other uses.

The name of the command has been chosen to be generic, so that it could
be later extended for other uses.

~~ General Rules

The following rules define how the '''call''' command is expected to
work:

 * The command accept ''-opts'' and ''-npos pos'' options.

 * The first argument after the options is the name of the command to call;

 * If ''-opts'' or ''-npos pos'' has been used, the command must be a
   Tcl-pure procedure.

 * If ''-npos pos'' option has been used, the following ''pos'' arguments
   are positional arguments for the command to call.

 * The following arguments are a list of ''-option value'' pairs, where
   ''option'' is the name of an argument with default of the target procedure
   and ''value'' is the value which will be assigned to this argument;

 * The order of ''-option value'' pairs is not important, they are not
   required to be declared in the same order than in the procedure;

 * An argument with default must only be declared once, doing otherwise will
   raise an error;

 * The list of ''-option value'' pairs stop as soon as the next argument does
   not start with a dash or when the ''--'' keyword is encountered;

 * All other arguments following the end of ''-option value'' list are
   affected to positional arguments '''without defaults'''.

~~ Examples

|% proc myproc { a { b B } { c C } args } {
|  puts "a:$a, b:$b, c:$c, args:$args"
|}
|
|% call -opts myproc -c valC A xyz
|a:A, b:B, c:valC, args:xyz
|
|% call -opts -npos 1 myproc valA -c valC -- -xyz
|a:valA, b:B, c:valC, args:-xyz
|
|% call -npos 2 myproc valA valB -xyz
|a:valA, b:valB, c:C, args:-xyz
|
|% dict set myargs -b "valB B"
|% dict set myargs -c C2
|% call -opts myproc {*}$myargs -- AA
|a:AA, b:valB B, c:C2, args:
|
|% call -opts myproc -optZ Z A
|unknown argument "optZ" in "myproc"
|
|% call -opts myproc -c c1 -c c2
|argument "c" is set more than once

~ Specification

This document proposes the following changes to the Tcl core:

 1. Implementation of the new '''call''' builtin command; The command
    will mainly create a new arguments list based on input arguments
    and arguments of the proc command. The new arguments list will then
    be used to call the command;

 2. The TclProcGetCachedArgs helper function is added to provide a direct
    access to local cache (variable names and default values) to the
    '''call''' command implementation;

 3. Add command documentation in doc/call.n;

 4. Add dedicated tests for the command in tests/call.test.

~ Reference Implementation

The reference implementation is available in the 457-CALL-CMD branch
[https://github.com/tcltk/tcl/compare/master...mlafon:457-CALL-CMD].
The code is licensed under the BSD license.

~ Discussion

This section detail the envisioned solutions for this feature, which can be
divided in four groups.

~~ Calling convention

Named arguments can be defined using a convention to specify them, without
requiring any change in the existing Tcl parser.

The convention can be to use the well-known ''-option value'' syntax:

|% myproc A -optB BB 

Or a more specific one to lessen the risk of collision with an existing
usage:

|% myproc A { @optB -> BB }

The drawbacks of this solution is that it may break existing code which
share a similar convention and that it is not possible to detect and
prevent its usage in non Tcl-pure procedures.

~~ Specific format

To avoid the drawbacks of the calling convention, it is possible to define
and use a specific format which is currently not accepted by the Tcl parser.

|% myproc "some pos arg" {optC}=foo {optB}={5 5}

This solution was the first proposal and has received mitigated feelings
from the Tcl community.

The drawbacks of this solution is that it is too far from the common
usage of the Tcl language and Tcl community and that it require important
changes in various parts of Tcl core.

An other variation of this solution, with a syntax more common to the usage
of the Tcl community, has also be proposed and can be used with argument
expansion:

|% myproc "some pos arg" {**}{optC foo optB {5 5}}

|% set args [dict create optC foo optB {5 5}]
|% myproc "some pos arg" {**}$args

~~ Modification in how proc are defined

Tcl-pure procedures can be defined in a way which state that the procedure
will automaticaly handle ''-option value'' arguments.

|% proc -np myproc { varA { optB defB } { optC defC } { optD defD } args } {
|  ..
|}
|% myproc -optC foo -optB {5 5} -- "some pos arg"

This is also how NSF handle parameters
[https://next-scripting.org/2.0.0/doc/nx/tutorial/index1#_parameters], as
proposed by the community:

|% nsf::proc myproc { varA {-optB defB} {-optC defC} } {
|  ..
|}

The drawbacks of this solution is that it does not meet the requirements
of not modifying the procedure. This does not allow to used named parameters
for procedure which can't be modified, for example from external packages.

~~ Dedicated builtin command

A dedicated command can be used to handle the named arguments, using an
''-option value'' syntax, before calling the target procedures with all
arguments correctly prepared.

|% call -opts myproc -optC foo -optB {5 5} -- "some pos arg"

This is the proposed solution in this TIP.

~ Copyright

This document has been placed in the public domain.
