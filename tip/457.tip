TIP:            457
Title:          Add Support for Named Arguments
Version:        $Revision: 1.16 $
Author:         Mathieu Lafon <mlafon@gmail.com>
Author:         Andreas Leitgeb <avl@logic.at>
State:          Draft
Type:           Project
Vote:           Pending
Created:        21-Nov-2016
Post-History:   
Keywords:       Tcl,procedure,argument handling
Tcl-Version:    8.7

~ Abstract

This TIP proposes an enhancement of the Tcl language to support named
arguments and additional features when calling a procedure.

~ Rationale

The naming of arguments to procedures is a computer language feature which
allow developers to specify the name of an argument when calling a function.
This is especially useful when dealing with arguments with default values, as
this does not require to specify all previous arguments when only one argument
is required to be specified.

As such, this is a commonly requested feature by Tcl developers, who have
created various code snippets [http://wiki.tcl.tk/10702] to simulate it. These
snippets have drawbacks: not intuitive for new users, require to add extra
code at the start of each procedure, no standard on the format to use, few
errors handling, etc.

After discussing various possibilities with the community, it has been
decided to extend the argument specification of the '''proc''' command
and allow users to define options on arguments. This can be used to
support named arguments but also add additional enhancements:
flag arguments, pass-by-name (''upvar'') arguments, non-required
arguments, ...

The others possibilities discussed are detailed in the ''Discussion''
section at the end of the document.

~ Specification

The ''proc'' documentation currently define argument specifiers as a list
of one or two fields where the first field is the name of the argument and
the optional second field is its default value.

The proposed modification is to support an alternate specifier format where
the first field is also the name of the argument, followed by a paired list
of options and their values. This format does not prevent the original format
to be used as they can be easily distinguished: the new format uses an
odd size list with a minimal size of three fields.

~~ Available argument specifiers

The following argument specifiers are defined in this TIP:

 * '''-default <val>''' defines the default value for the argument.

|% proc p { { a -default {} } } { list a $a }
|% p
|a {}
|% p foo
|a foo

 * '''-name NAME''' defines the argument to be a named argument.
   NAME defines the name of the argument when it is  defined as a
   single string. If NAME is a list of strings, it is the list of
   names that can be used to refer to the argument (i.e. aliases).
   On the call-site, the name of the argument is prefixed by a single dash
   and followed by the value.

|% proc p1 { { v -name val } } { list v $v }
|% p1 -val 1
|v 1

|% proc p2 { { v -name {v val value} } } { list v $v }
|% p2 -value 2
|v 2
|% p2 -v 2
|v 2

 * '''-switch SWITCHES''' defines that the argument is defined on the
   call-site as a flag-only/switch parameter. SWITCHES is a list of
   possible switches. Each switch is defined either as a single string
   (switch name) or as a list of two entries (switch name and related
   value). On the call-site, the name of the switch is prefixed by a
   single dash and is not followed by any value. The value assigned to
   the argument is either the switch name or the related value depending
   on how it was defined.

|% proc p { { dbg -default 0 -switch debug } } { list dbg $dbg }
|% p
|dbg 0
|% p -debug
|dbg debug

|% proc p { { level -switch {{quiet 0} {verbose 9}} } { list level $level }
|% p -quiet
|level 0
|% p -verbose
|level 9

 * '''-required BOOLEAN''' defines that the value is required to be set.
   If not set (i.e. default behaviour) or set to true, an error will be
   raised if the argument is not set and has no default value. If set to
   false and if the parameter has no default value and has not been set,
   no error will be raised and the argument will be left unset.

|% proc p { { v -name val -required 0 }  } {
|    if {[info exist v]} {list v $v} {return "v is unset"}
|  }
|% p -val 5
|v 5
|% p
|v is unset

 * '''-upvar BOOLEAN''' defines, when set to true, that the local
   argument will be linked to the variable in caller's scope. This is
   similar to what is achieved when using the ''upvar'' command.

|% proc p { { v -upvar 1 } } { incr v }
|% set a 2
|2
|% p a
|3

 * '''-varname VARNAME''' defines the name of a variable which will be
   created with the original value of the parameter. When used with
   '''-upvar true''', the variable's value will be the name of the
   linked variable in the caller's scope.

|% proc p { { v -upvar 1 -varname nm } } { incr v; list $nm "incremented" }
|% set a 4
|4
|% p a
|a incremented
|% set a
|5

Further argument specifiers may be added in future TIP. Examples of
new argument specifiers which may be added in the future:

 * type assertion ('''-assume TYPE''')
 * argument documentation ('''-docstring DOC''')
 * ...

~~ Named arguments

The following rules define how named arguments are expected to be specified
on the call-site:

 * Named arguments must always be specified using their name, they can't be
   specified as positional arguments.

|% proc p { {a -name A} } { list a $a }
|% p aa
|wrong # args: should be "p |-A a|"
|% p -A aa
|a aa

 * When several names (using '''-name''' or '''-switch''' options) are
   specified for the same argument, only one is required to be used on
   the call-site, unless a default value is also specified. If more than
   one is used, the latest value/switch is kept.

|% proc p { { v -name {v val} } } { list v $v }
|% p -v 6 -val 8
|v 8

 * Both '''-name''' and '''-switch''' specifiers can be used on the same
   argument.

|% proc p { { level -name level -switch {{quiet 0} {verbose 9}} } {
|    list level $level
|  }
|% p -level 4
|level 4
|% p -verbose
|level 9

 * A group of contiguous named arguments are handled together and are not
   required to be specified in the same order as defined.

|% proc p { {a -name A} {b -name B} } { list a $a b $b }
|% p -B bb -A aa
|% a aa b bb

 * The handling of a group of contiguous named arguments (which can be
   only one argument) is ended on the first argument not starting with
   a dash or by using the special ''--'' end-of-options marker. Remaining
   arguments will then be assigned to following positional arguments.

|% proc p { {o -name opt} args } { list o $o args $args }
|% p -opt O 5
|o O args 5
|% p -opt O -1 0
|wrong # args: should be "p |-opt o| ?arg ...?"
|% p -opt O -- -1 0
|o O args {-1 0}

~~ Generated usage description

The error message, automatically generated when the input arguments are
invalid, is updated regarding new options:

 * Pass-by-name arguments (specified using '''-upvar true''' option) are
   surrounded by the '&' character.

|% proc p { { v -upvar 1 } } { }
|% p
|wrong # args: should be "p &v&"

 * Named arguments are showed how they should be called and surounded
   by the '|' character. If several names have been specified,
   they are grouped together.

|% proc p { { l -name level -switch {high low}} } {}
|% p
|wrong # args: should be "p |-level l|-high|-low|"

 * When a default value has been specified or if '''-required false'''
   has been set, the '?' is used.

|% proc p { { v -default 0 -name var } a } {}
|% p
|wrong # args: should be "p ?|-var v|? a"

~~ Introspection

The ''info argspec'' command is added to get the argument specification
of all arguments or of a specific argument.

|% proc p { a { b 1 } { c -name c } } {}
|% info argspec p
|a { b -default 1 } { c -name c }
|% info argspec p c
|-name c

~~ Performance

The handling of the new argument specifiers during a ''proc'' call has
a minimal, but non-null impact on performance. Initial testing on a
*non-optimized* implementation has shown a speed decrease of only 10%-20%,
which must be compared to a decrease of nearly 900% when using a Tcl-pure
implementation

|proc p1 {a b {c 0} {d 0} {e 0} {f 0} {g 0} {h 0}} {
|  list $a $b $c $d $e $f $g $h
|}
|proc p2 {a b args} {
|  array set opt [concat {-C 0 -D 0 -E 0 -F 0 -G 0 -H 0} $args]
|  list $a $b $opt(-C) $opt(-D) $opt(-E) $opt(-F) $opt(-G) $opt(-H)
|}
|proc p3 {a b {c -default 0 -name C} {d -default 0 -name D} {e -default 0 -name E} {f -default 0 -name F} {g -default 0 -name G} {h -default 0 -name H}} {
|  list $a $b $c $d $e $f $g $h
|}
|puts "default:  [time {p1 A B 0 0 0 8 0 42} 1000000]"
|puts "Tcl-pure: [time {p2 A B -F 8 -H 42}   1000000]"
|puts "TIP-457:  [time {p3 A B -F 8 -H 42}   1000000]"

|default:  0.604988 microseconds per iteration
|Tcl-pure: 5.378907 microseconds per iteration  (+889%)
|TIP-457:  0.698328 microseconds per iteration  (+ 15%)

Users with critical requirements on speed should be warned and may
prefer not using extended argument specifiers.

The performance of a Tcl-pure procedure defined without any extended
argument specifiers is not affected by the modification because the
original initialization code is still used in that case.

~ Implementation

This document proposes the following changes to the Tcl core:

 1. Add ExtendedArgSpec structure which is linked from CompiledLocal
    and contains information about extended argument specification;

 2. Add a flags field in the Proc structure to later identify a proc
    with at least one argument defined with an extended argument
    specification (PROC_HAS_EXT_ARG_SPEC);

 3. Update proc creation to handle the extended argument specification
    and fill the ExtendedArgSpec structure;

 4. Update InitArgsAndLocals to initialize the compiled locals using
    a dedicated function if the PROC_HAS_EXT_ARG_SPEC flag has been
    set on the proc. If unset, the original initialization code is
    still used.

 5. Update ProcWrongNumArgs to generate an appropriate error message
    when an argument has been defined using an extended argument
    specification;

 6. Add ''info argspec'' command;

 7. Update documentation in doc/proc.n;

 8. Update impacted tests and add dedicated tests in tests/proc-enh.test.

~~ Reference Implementation

The reference implementation is available in the tip-457
[http://core.tcl.tk/tcl/timeline?r=tip-457] branch.

The code is licensed under the BSD license.

~ Discussion

This section details some of the envisioned solutions for this feature.

Initial approaches that tried to work with unmodified procedures are
not detailed here for clarity.

~~ Dedicated builtin command

A dedicated command can be used to handle the named arguments, using an
''-option value'' syntax, before calling the target procedures with all
arguments correctly prepared.

|% call -opts myproc -optC foo -optB {5 5} -- "some pos arg"

An implementation of this proposal is available at
[https://github.com/mlafon/tcl/tree/457-CALL-CMD]. This proposal was
abandoned as it was not enough intuitive for users.

~~ Modification in how proc are defined

Tcl-pure procedures can be defined in a way which state that the procedure
will automatically handle ''-option value'' arguments.

|% proc -np myproc { varA { optB defB } { optC defC } { optD defD } args } { .. }
|% myproc -optC foo -optB {5 5} -- "some pos arg"

An other possibility is to support options on arguments and allow name
specification:

|% proc myproc { varA { optB -default defB -name B } args } { .. }
|% myproc a -B b zz

This is the currently proposed solution in this TIP. It requires the
procedures to be modified but allow additional features.

~~ Argument Parsing extension

Cyan Ogilvie's paper from Tcl2016 [https://www.tcl.tk/community/tcl2016/assets/talk33/parse_args-paper.pdf]
describes a C extension to provide core-like argument parsing at speed
comparable to ''proc'' argument handling, in a terse and self-documenting
way.

~ Copyright

This document has been placed in the public domain.
