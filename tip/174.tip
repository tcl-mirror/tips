TIP:            174
Title:          Math Operators as Commands
Version:        $Revision: 1.5 $
Author:         Kristoffer Lawson <setok@altparty.org>
Author:         Donal K. Fellows <donal.k.fellows@man.ac.uk>
Author:         David S. Cargo <escargo@skypoint.com>
Author:         Peter Spjuth <peter.spjuth@space.se>
State:          Draft
Type:           Project
Vote:           Pending
Created:        15-Mar-2004
Post-History:   
Tcl-Version:    8.5

~ Abstract

This TIP describes a proposal for math operators in Tcl as separate
commands, acting much like the equivalent in the Lisp language.  This
would make simple usage of mathematics much clearer.

~ Rationale

While the [[expr]] command works fairly well for longer mathematical
expressions, it is extremely tedious for the most common uses, such as
handling indices.  Take the following examples:

| set newList [lrange $list [expr {$idx - 5}] [expr {$idx + 5}]]
| .c create oval [expr {$x - $r}] [expr {$y - $r}] [expr {$x + $r}] [expr {$y + $r}]

Many find this particular aspect of Tcl unappealing.  It gets
increasingly difficult to read as more and more simple mathematical
expressions build up.

~ Proposed Change

 1. A group of Tcl commands are added which would handle mathematical
    operations without the need to use [[expr]].  Most commands would
    take a variable amount of arguments and would work such that the
    operator is applied to the combination of the first and second
    arguments.  The result of this combination is then used with the
    operator for the third argument, etc.  If only one argument is
    given, it is returned as is.  See below for details for each operator.
    A sample implementation of the ''+'' command in Tcl follows:

| proc ::tcl::mathop::+ {args} {
|     set r 0
|     foreach operand $args {
|         set r [expr {$r + $operand}]
|     }
|     return $r
| }

 2. All operator commands will be kept in the ::tcl::mathop
    (in line with ::tcl::mathfunc from [232])
    namespace, from which they would most commonly be imported to the
    global namespace.

 3. The commands are not connected to their corresponding expr operator.
    Overloading or adding any command in ::tcl::mathop does not affect
    operators in expr or any other command that calls ''Tcl_ExprObj''.

~ Operator commands details

Unary operators ~ ! always take one argument.

Operators that naturally allow 0 or more arguments do so:

|Op/argc  0   1   2     3-
|+        0   a   a+b   a+b+c...
|*        1   a   a*b   a*b*c...
|&       -1   a   a&b   a&b&c...
|^        0   a   a^b   a^b^c...
||        0   a   a|b   a|b|c...

Other left or right associative operators.
Operator ** is right associative, which needs to be noted clearly.

|Op/argc  0   1   2     3-
|**       1   a   a**b  a**(b**(c...))
|<<       err a   a<<b  ((a<<b)<<c)...
|>>       err a   a>>b  ((a>>b)>>c)...
|%        err a   a%b   ((a%b)%c)...

Unary minus is negation. Unary divide is inversion.

|Op/argc  0   1     2    3-
|-        err -a    a-b  ((a-b)-c)...
|/        err 1.0/a a/b  ((a/b)/c)...

Comparison operators < > <= >= == != "eq" "ne" always take two args.

List operators "in" "ni" always take two args.

Logical operators && || are not included to avoid confusion since
they will not be lazy and thus do not exactly correspond to their
expr counterparts.

Operator x?y:z is not included.

~ Example

As an example use, let us change the lines from above:

| set newList [lrange $list [- $idx 5] [+ $idx 5]]
| .c create oval [- $x $r] [- $y $r] [+ $x $r] [+ $y $r]

This is clearly shorter and much easier on the eyes.  There is no need
to consider the effects of bracing expressions.

Sum of a list becomes

| set sum [+ {expand}$list]

~ Possible additions

Extend comparison operators to allow variadic args. Zero ore one arg
returns true and with three args it becomes e.g. "(a op b) && (b op c)".
That offers the opportunity to test "is this list sorted?"
with [<= {expand}$list].

Include && and || as logical operators. Add ^^ operator for logical xor.

~ Implementation

These commands can naturally be compiled and thus as efficient
as their corresponding expr operators. The following lines
should probably result in the same byte codes.

|set x [expr {$a * $b + $c}]
|set x [+ [* $a $b] $c]

~ Copyright

This document has been placed in the public domain.
